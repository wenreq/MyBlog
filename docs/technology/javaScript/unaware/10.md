---
lang: zh-CN
title: 5. 原型
description: 原型
---

第 4 章中介绍的所有模拟类复制行为的方法，如各种混入，都没有使用 `[[Prototype]]` 链机制。

## 5.1 `[[Prototype]]`

JavaScript 中的对象有一个特殊的 `[[Prototype]]` 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 `[[Prototype]]` 属性都会被赋予一个非空的值。

```js
var myObject = {
  a: 2
};
myObject.a; // 2
```

`[[Prototype]]` 引用有什么用呢？在第 3 章中我们说过，当你试图引用对象的属性时会触发 `[[Get]]` 操作，比如  `myObject.a`。对于默认的 `[[Get]]` 操作来说，第一步是**检查对象本身**是否有这个属性，如果有的话就使用它。

要注意，如果包含 `Proxy` 的话，我们这里对 `[[Get]]` 和 `[[Put]]` 的讨论就不适用。

但是如果 a 不在 myObject 中，就需要使用对象的 `[[Prototype]]` 链了。

**对于默认的 `[[Get]]` 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 `[[Prototype]]` 链**:

```js
var anotherObject = {
  a: 2
};
// 创建一个关联到 anotherObject 的对象
var myObject = Object.create( anotherObject );
myObject.a; // 2
```

`Object.create(..)` 的原理，现在只需要知道它会**创建一个对象并把这个对象的 `[[Prototype]]` 关联到指定的对象**。

现在 myObject 对象的 `[[Prototype]]` 关联到了 anotherObject。显然 myObject.a 并不存在，但是尽管如此，属性访问仍然成功地（在 anotherObject 中）找到了值 2。但是，如果 anotherObject 中也找不到 a 并且 `[[Prototype]]` 链不为空的话，就会继续查找下去。这个过程会持续到找到匹配的属性名或者查找完整条 `[[Prototype]]` 链。如果是后者的话，`[[Get]]` 操作的返回值是 `undefined`。

使用 `for..in` 遍历对象时原理和查找 `[[Prototype]]` 链类似，任何可以通过原型链访问到（并且是 `enumerable`，参见第 3 章）的属性都会被枚举。使用 `in` 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链（无论属性是否可枚举）：

```js
var anotherObject = {
  a: 2
};
// 创建一个关联到 anotherObject 的对象
var myObject = Object.create( anotherObject );
for (var k in myObject) {
  console.log("found: " + k);
}
// found: a
("a" in myObject); // true
```

因此，当你通过各种语法进行属性查找时都会查找 `[[Prototype]]` 链，直到找到属性或者查找完整条原型链。

### 5.1.1 `Object.prototype`

但是到哪里是 `[[Prototype]]` 的 “尽头” 呢？

所有普通的 `[[Prototype]]` 链最终都会指向内置的 `Object.prototype`。由于所有的 “普通”（内置，不是特定主机的扩展）对象都 “源于”（或者说把 `[[Prototype]]` 链的顶端设置为）这个 `Object.prototype` 对象，所以它包含 JavaScript 中许多通用的功能。

有些功能你应该已经很熟悉了， 比如说 `.toString()` 和 `.valueOf()`， 第3章还介绍过 `.hasOwnProperty(..)`。稍后我们还会介绍 `.isPrototypeOf(..)`，这个你可能不太熟悉。

### 5.1.2 属性设置和屏蔽

给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性值。

```js
myObject.foo = "bar";
```

如果 myObject 对象中包含名为 foo 的普通数据访问属性，这条赋值语句只会修改已有的属性值。

如果 foo 不是直接存在于 myObject 中，`[[Prototype]]` 链就会被遍历，类似 `[[Get]]` 操作。如果原型链上找不到 foo，foo 就会被直接添加到 myObject 上。

然而，如果 foo 存在于原型链上层，赋值语句 `myObject.foo = "bar"` 的行为就会有些不同。

如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 `[[Prototype]]` 链上层，那么就会发生**屏蔽**。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 `myObject.foo` **总是会选择原型链中最底层**的 foo 属性。

屏蔽比我们想象中更加复杂。下面我们分析一下如果 foo 不直接存在于 myObject 中而是存在于原型链上层时 `myObject.foo = "bar"` 会出现的三种情况。

1. 如果在 `[[Prototype]]` 链上层存在名为 foo 的普通数据访问属性并且**没有被标记**为只读（`writable:false`），那就会直接在 myObject 中**添加**一个名为 foo 的新属性，它是**屏蔽属性**。
2. 如果在 `[[Prototype]]` 链上层存在 foo，但是它**被标记**为只读（`writable:false`），那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，**不会**发生屏蔽。
3. 如果在 `[[Prototype]]` 链上层存在 foo 并且它是一个 setter，那就一定会调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这个 setter。

大多数开发者都认为如果向 `[[Prototype]]` 链上层已经存在的属性（`[[Put]]`）赋值，就一定会触发屏蔽，但是如你所见，三种情况中只有一种（第一种）是这样的。

如果你希望在第二种和第三种情况下也屏蔽 foo，那就不能使用 `=` 操作符来赋值，而是使用 `Object.defineProperty(..)`（参见第 3 章）来向 myObject 添加 foo。

如果需要对屏蔽方法进行委托的话就不得不使用丑陋的显式伪多态（参见第 4 章）。通常来说，使用屏蔽得不偿失，所以应当尽量避免使用。第 6 章会介绍另一种不使用屏蔽的更加简洁的设计模式。

有些情况下会**隐式产生屏蔽**，一定要当心。思考下面的代码：

```js
var anotherObject = {
  a: 2
};
var myObject = Object.create( anotherObject );
anotherObject.a; // 2
myObject.a; // 2 
anotherObject.hasOwnProperty( "a" ); // true
myObject.hasOwnProperty( "a" ); // false 

myObject.a++; // 隐式屏蔽！

anotherObject.a; // 2 
myObject.a; // 3 

myObject.hasOwnProperty( "a" ); // true
```

尽管 `myObject.a++` 看起来应该（通过委托）查找并增加 `anotherObject.a` 属性，但是别忘了 `++` 操作相当于 `myObject.a = myObject.a + 1`。因此 `++` 操作首先会通过 `[[Prototype]]`查找属性 a 并从 `anotherObject.a` 获取当前属性值 2，然后给这个值加 1，接着用 `[[Put]]` 将值 3 赋给 `myObject` 中新建的屏蔽属性 a，天呐！

修改委托属性时一定要小心。如果想让 `anotherObject.a` 的值增加，唯一的办法是 `anotherObject.a++`。

## 5.2 “类”

JavaScript 才是真正应该被称为 “面向对象” 的语言，因为它是少有的可以不通过类，直接创建对象的语言。

在 JavaScript 中，类无法描述对象的行为，（因为根本就不存在类！）对象直接定义自己的行为。再说一遍，JavaScript 中只有对象。

### 5.2.1 “类” 函数

```js
function Foo() {
 // ...
}
var a = new Foo();
Object.getPrototypeOf( a ) === Foo.prototype; // true
```

调用 new Foo() 时会创建 a，其中一步就是将 a 内部的 `[[Prototype]]` 链接到 Foo.prototype 所指向的对象。

在面向类的语言中，**类可以被复制（或者说实例化）多次**，就像用模具制作东西一样。之所以会这样是因为实例化（或者继承）一个类就意味着 “把类的行为复制到物理对象中”，对于每一个新实例来说都从重复这个过程。

但是在 JavaScript 中，并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们 `[[Prototype]]` 关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是**互相关联**的。

`new Foo()` 会生成一个新对象（我们称之为 a），这个新对象的内部链接 `[[Prototype]]` 关联的是 `Foo.prototype` 对象。

#### 关于名称

继承意味着复制操作，JavaScript 并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过**委托**访问另一个对象的属性和函数。委托这个术语更加准确地描述了 JavaScript 中对象的关联机制。

### 5.2.2 “构造函数”

```js
function Foo() {
 // ...
}
Foo.prototype.constructor === Foo; // true
var a = new Foo();
a.constructor === Foo; // true
```

`Foo.prototype` 默认（在代码中第一行声明时！）有一个公有并且不可枚举的属性 `.constructor`，这个属性引用的是**对象关联的函数**（本例中是 Foo）。此外，我们可以看到通过 “构造函数” 调用 new Foo() 创建的对象也有一个 `.constructor` 属性，指向
“创建这个对象的函数”。

按照 JavaScript 世界的惯例，“类” 名首字母要大写，所以名字写作 Foo 而非 foo 似乎也提示它是一个“类”。显而易见，是吧 ?!

#### 1. 构造函数还是调用

上一段代码很容易让人认为 Foo 是一个构造函数，因为我们使用 `new` 来调用它并且看到 “构造” 了一个对象。

实际上，Foo 和你程序中的其他函数没有任何区别。函数本身并不是构造函数，然而，当你在普通的函数调用前面加上 `new` 关键字之后，就会把这个函数调用变成一个 “构造函数调用”。实际上，`new` 会劫持所有普通函数并**用构造对象的形式来调用它**。

```js
function NothingSpecial() {
 console.log( "Don't mind me!" );
}
var a = new NothingSpecial();
// "Don't mind me!"
a; // {}
```

NothingSpecial 只是一个普通的函数，但是使用 `new` 调用时，它就会构造一个对象并赋值给 a，这看起来像是 `new` 的一个副作用（无论如何都会构造一个对象）。这个调用是一个**构造函数调用**，但是 NothingSpecial 本身并不是一个构造函数。

换句话说，在 JavaScript 中对于 “构造函数” 最准确的解释是，**所有带 `new` 的函数调用**。

***函数不是构造函数，但是当且仅当使用 `new` 时，函数调用会变成 “构造函数调用”。***

### 5.2.3 技术

JavaScript 开发者绞尽脑汁想要模仿类的行为：

```js
function Foo(name) {
  this.name = name;
}
Foo.prototype.myName = function() {
  return this.name;
};
var a = new Foo( "a" );
var b = new Foo( "b" );
a.myName(); // "a"
b.myName(); // "b"
```

这段代码展示了另外两种 “面向类” 的技巧：

1. this.name = name 给每个对象都添加了 .name 属性，有点像类实例封装的数据值。
2. `Foo.prototype.myName = ...` 可能个更有趣的技巧，它会给 Foo.prototype 对象添加一个属性（函数）。现在，a.myName() 可以正常工作。

在这段代码中，看起来似乎创建 a 和 b 时会把 Foo.prototype 对象复制到这两个对象中，然而事实并不是这样。

在本章开头介绍默认 `[[Get]]` 算法时我们介绍过 `[[Prototype]]` 链，以及当属性不直接存在于对象中时如何通过它来进行查找。

因此，在创建的过程中，a 和 b 的内部 [[Prototype]] 都会关联到 Foo.prototype 上。当 a 和 b 中无法找到 myName 时，它会（通过委托，参见第 6 章）在 Foo.prototype 上找到。

#### 回顾 “构造函数”

之前讨论 `.constructor` 属性时我们说过，看起来 `a.constructor === Foo` 为真意味着 `a` 确实有一个指向 `Foo` 的 `.constructor` 属性，但是事实不是这样。

这是一个很不幸的误解。实际上，`.constructor` 引用同样被委托给了 `Foo.prototype`，而 `Foo.prototype.constructor` 默认指向 `Foo`。

`.constructor` 属性指向 Foo 看作是 a 对象由 Foo “构造” 非常容易理解，但这只不过是一种虚假的安全感。`a.constructor` 只是通过默认的 `[[Prototype]]` 委托指向 Foo，这和 “构造”毫无关系。相反，对于 .constructor 的错误理解很容易对你自己产生误导。

`Foo.prototype` 的 `.constructor` 属性只是 `Foo` 函数在声明时的默认属性。如果你创建了一个新对象并替换了函数默认的 `.prototype` 对象引用，那么新对象并**不会**自动获得 `.constructor` 属性。

```js
function Foo() { /* .. */ }
Foo.prototype = { /* .. */ }; // 创建一个新原型对象
var a1 = new Foo();
a1.constructor === Foo; // false!
a1.constructor === Object; // true!
```

`Object(..)` 并没有 “构造” `a1`，对吧？看起来应该是 `Foo()` “构造” 了它。大部分开发者都认为是 `Foo()` 执行了构造工作，但是问题在于，如果你认为 “constructor” 表示“由……构造” 的话，`a1.constructor` 应该是 `Foo`，但是它并不是 `Foo` ！

到底怎么回事？ a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo.prototype。但是这个对象也没有 .constructor 属性（不过默认的 Foo.prototype 对象有这个属性！），所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象有 .constructor 属性，指向内置的 Object(..) 函数。

错误观点已被摧毁。

当然，你可以给 Foo.prototype 添加一个 .constructor 属性，不过这需要手动添加一个符
合正常行为的不可枚举（参见第 3 章）属性。

```js
function Foo() { /* .. */ }
Foo.prototype = { /* .. */ }; // 创建一个新原型对象
// 需要在 Foo.prototype 上“修复”丢失的 .constructor 属性
// 新对象属性起到 Foo.prototype 的作用
// 关于 defineProperty(..)，参见第 3 章
Object.defineProperty( Foo.prototype, "constructor" , {
  enumerable: false,
  writable: true,
  configurable: true,
  value: Foo // 让 .constructor 指向 Foo
} );
```

修复 .constructor 需要很多手动操作。所有这些工作都是源于把 “constructor” 错误地理解为“由……构造”，这个误解的代价实在太高了。

实际上，对象的 `.constructor` 会默认指向一个函数，这个函数可以通过对象的 `.prototype` 引用。 “constructor” 和 “prototype” 这两个词本身的含义可能适用也可能不适用。最好的办法是记住这一点 **“constructor 并不表示被构造”**。

`.constructor` 并不是一个不可变属性。它是**不可枚举**（参见上面的代码）的，但是它的值是**可写的**（可以被修改）。此外，你可以给任意 `[[Prototype]]` 链中的任意对象添加一个名为 `constructor` 的属性或者对其进行修改，你可以任意对其赋值。

和 `[[Get]]` 算法查找 `[[Prototype]]` 链的机制一样，`.constructor` 属性引用的目标可能和你想的完全不同。

`a1.constructor` 是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。

## 5.3 （原型）继承

### 检查“类”关系

## 5.4 对象关联

### 5.4.1 创建关联

### 5.4.2 关联关系是备用

## 5.5 小结
