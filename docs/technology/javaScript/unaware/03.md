---
lang: zh-CN
title: 3. 函数作用域和块作用域
description: 函数作用域和块作用域
---

## 3.1 函数中的作用域

JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。但事实上这并不完全正确，下面我们来看一下。

首先需要研究一下函数作用域及其背后的一些内容。

```js
function foo(a) {
  var b = 2;
  // 一些代码
  function bar() {
    // ...
  } 
  // 更多的代码
  var c = 3;
}
```

在这个代码片段中，`foo(..)` 的作用域气泡中包含了标识符 `a`、`b`、`c` 和 `bar`。无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡。

`bar(..)` 拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，它只包含了一个标识符：`foo`。

这些标识符全都无法从全局作用域中进行访问，因此下面的代码会导致 `ReferenceError` 错误：

```js
bar(); // 失败
console.log( a, b, c ); // 三个全都失败
```

函数作用域的含义是指，**属于这个函数的全部变量都可以在整个函数的范围内使用及复用**（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 `JavaScript` 变量可以根据需要改变值类型的 “动态” 特性。

## 3.2 隐藏内部实现

可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来 “隐藏” 它们。

为什么 “隐藏” 变量和函数是一个有用的技术？

有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该**最小限度地暴露必要内容**，而将其他内容都 “隐藏” 起来，比如某个模块或对象的 API 设计。

这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会*破坏*前面提到的**最小特权原则**，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是*私有*的，正确的代码应该是可以阻止对这些变量或函数进行访问的。

```js
function doSomething(a) {
  b = a + doSomethingElse( a * 2 );
  console.log( b * 3 );
}
function doSomethingElse(a) {
  return a - 1;
}
var b;
doSomething( 2 ); // 15
```

在这个代码片段中，变量 `b` 和函数 `doSomethingElse(..)` 应该是 `doSomething(..)` 内部具体实现的 “私有” 内容。更 “合理” 的设计会将这些私有的具体内容隐藏在 `doSomething(..)` 内部，例如：

```js
function doSomething(a) {
  function doSomethingElse(a) {
    return a - 1;
  }
  var b;
  b = a + doSomethingElse( a * 2 );
  console.log( b * 3 );
}
doSomething( 2 ); // 15
```

现在，`b` 和 `doSomethingElse(..)` 都无法从外部被访问，而只能被 `doSomething(..)` 所控制。功能性和最终效果都没有受影响，但是**设计上将具体内容私有化**了，设计良好的软件都会依此进行实现。

### 规避冲突

“隐藏” 作用域中的变量和函数所带来的另一个好处，是可以**避免同名标识符之间的冲突**，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被*意外覆盖*。

#### 1.全局命名空间

当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

这些库通常会在全局作用域中声明一个名字**足够独特的变量**，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。

```js
var MyReallyCoolLibrary = {
  awesome: "stuff",
  doSomething: function() {
    // ...
  },
  doAnotherThing: function() {
    // ... 
  }
};
```

#### 2.模块管理

另外一种避免冲突的办法和现代的*模块*机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。

## 3.3 函数作用域

我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义 “隐藏” 起来，外部作用域无法访问包装函数内部的任何内容。

如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够*自动运行*，这将会更加理想。

区分函数声明和表达式最简单的方法是看 `function` 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 `function` 是**声明中的第一个词**，那么就是一个**函数声明**，否则就是一个函数表达式。

函数声明和函数表达式之间最重要的区别是**它们的名称标识符将会绑定在何处**。

### 3.3.1 匿名和具名

对于函数表达式你最熟悉的场景可能就是回调参数了，比如：

```js
setTimeout( function() {
  console.log("I waited 1 second!");
}, 1000 );
```

这叫作匿名函数表达式，因为 `function()..` 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 `JavaScript` 的语法中这是非法的。

匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有*几个缺点*需要考虑。

1. 匿名函数在**栈追踪**中不会显示出有意义的函数名，使得调式很困难。
2. 如何没有函数名，当函数需要引用自身时只能使用已经*过期*的 `arguments.callee` 引用。比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
3. 匿名函数省略了对于代码**可读性/可理解性**很重要的函数名。一个描述性的名称可以让代码不言自明。

**行内函数表达式**非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：

```js
setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
  console.log( "I waited 1 second!" );
}, 1000 );
```

### 3.3.2 立即执行函数表达式

```js
var a = 2;
(function foo() {
  var a = 3;
  console.log( a ); // 3
})();
console.log( a ); // 2
```

`IIFE`，代表立即执行函数表达式（Immediately Invoked Function Expression）。

相较于传统的 `IIFE` 形式，很多人都更喜欢另一个改进的形式：`(function(){ .. }())`。

这两种形式在功能上是一致的。选择哪个**全凭个人喜好**。

`IIFE` 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。

```js
var a = 2;
(function IIFE( global ) {
  var a = 3;
  console.log( a ); // 3
  console.log( global.a ); // 2
})( window );
console.log( a ); // 2
```

## 3.4 块级作用域

```js
for (var i=0; i<10; i++) {
  console.log( i );
}
```

为什么要把一个只在 `for` 循环内部使用（至少是应该只在内部使用）的变量 `i` 污染到整个函数作用域中呢？

更重要的是，开发者需要检查自己的代码，以避免在作用范围外意外地使用（或复用）某些变量，如果在错误的地方使用变量将导致未知变量的异常。变量 `i` 的块作用域（如果存在的话）将使得其只能在 `for` 循环内部使用，*如果在函数中其他地方使用会导致错误*。这对保证变量不会被混乱地复用及提升代码的可维护性都有很大帮助。

### 3.4.1 with

`with` 从对象中创建出的作用域仅在 `with` **声明中**而非外部作用域中有效。

### 3.4.2 try/catch

非常少有人会注意到 JavaScript 的 `ES3` 规范中规定 `try/catch` 的 `catch` 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。

```js
try {
  undefined(); // 执行一个非法操作来强制制造一个异常
}
catch (err) {
  console.log( err ); // 能够正常执行！
}
console.log( err ); // ReferenceError: err not found
```

### 3.4.3 let

`let` 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，`let` 为其声明的变量隐式地劫持了所在的块作用域。

```js
var foo = true;
if (foo) {
  let bar = foo * 2;
  bar = something( bar );
  console.log( bar );
}
console.log( bar ); // ReferenceError
```

但是使用 `let` 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不 “存在”。

#### 1. 垃圾收集

另一个块作用域非常有用的原因和**闭包**及**回收内存垃圾的回收机制**相关。

为变量显式声明块作用域，并对变量进行本地绑定是非常有用的工具，可以把它添加到你的代码工具箱中了。

#### 2. let 循环

```js
for (let i=0; i<10; i++) {
  console.log( i );
}
console.log( i ); // ReferenceError
```

`for` 循环头部的 `let` 不仅将 `i` 绑定到了 `for` 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。

### 3.4.4 const

除了 `let` 以外，`ES6` 还引入了 `const`，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。

```js
var foo = true;
if (foo) {
  var a = 2;
  const b = 3; // 包含在 if 中的块作用域常量
  a = 3; // 正常 !
  b = 4; // 错误 !
}
console.log( a ); // 3
console.log( b ); // ReferenceError!
```

## 小结

函数是 JavaScript 中最常见的作用域单元，本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。

但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。

`ES3` 开始，`try/catch` 结构在 `catch` 分句中具有块作用域。

在 `ES6` 中引入了 `let` 关键字（var 关键字的表亲），用来在任意代码块中声明变量。`if(..) { let a = 2; }` 会声明一个劫持了 `if` 的 { .. } 块的变量，并且将变量添加到这个块中。

有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。
