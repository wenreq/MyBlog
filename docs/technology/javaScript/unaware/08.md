---
lang: zh-CN
title: 3. 对象
description: 对象
---

## 3.1 语法

对象可以通过两种形式定义：**声明**（文字）形式和**构造**形式。

对象的声明（文字）语法大概是这样的：

```js
var myObject = {
  key: value,
  // ...
}
```

构造形式大概是这样的：

```js
var myObject = new Object();
myObject.key = value;
```

构造形式和文字声明形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个键/值对，但是在构造形式中你必须逐个添加属性。

用上面的 “构造形式” 来创建对象是非常少见的，一般来说你会使用文字语法，绝大多数内置对象也是这样做的。

## 3.2 类型

对象是 JavaScript 的基础。在 JavaScript 中一共有六种主要类型（术语是“语言类型”）：

- string
- number
- boolean
- null
- undefined
- object

注意，简单基本类型（`string`、`boolean`、`number`、`null` 和 `undefined`）本身并不是对象。`null` 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 `null` 执行`typeof null` 时会返回字符串 "object"。实际上，`null` 本身是基本类型。（原理是这样的，不同的对象在底层都表示二进制，在JavaScript中二进制前三位都为 0 的话会被判断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回 “object”）。

有一种常见的错误说法是 “JavaScript 中万物皆是对象”，这显然是**错误**的。

实际上，JavaScript 中有许多特殊的**对象子类型**，我们可以称之为复杂基本类型。

函数就是对象的一个子类型（从技术角度来说就是 “可调用的的对象”）。JavaScript 中的函数是 “一等公民”，因为它们本质上和普通的对象一样（只是可以调用），所以可以像操作其他对象一样操作函数（比如当做另外一个函数的参数）。

数组也是对象的一种类型，具备一些额外的行为。数组中内容的组织方式比一般的对象要稍微复杂一些。

### 内置对象

JavaScript 中还有一些对象子类型，通常被称为**内置对象**。有些内置对象的名字看起来和简单基础类型一样，不过实际上它们的关系更复杂。

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error

这些内置对象从表现形式来说很像其他语言中的类型（type）或者类（class），比如 Java 中的 String 类。

但是在 JavaScript 中，它们实际上只是一些内置函数。这些内置函数可以当作**构造函数**（由 new 产生的函数调用）来使用，从而可以**构造一个对应子类型的新对象**。举例来说：

```js
var strPrimitive = "I am a string";
typeof strPrimitive; // "string"
strPrimitive instanceof String; // false

var strObject = new String( "I am a string" );
typeof strObject; // "object"
strObject instanceof String; // true

// 检查 sub-type 对象 
Object.prototype.toString.call(strObject); // [object String]
```

我们可以认为子类型在内部借用了 `Object` 中的 `toString()` 方法。从代码中可以看到，strObject 是由 `String` 构造函数创建的一个对象。

原始值 "I am a string" 并不是一个对象，它只是一个字面量，并且是一个不可变的值。如果要在这个字面量上执行一些**操作**，比如获取长度、访问其中某个字符等，那需要将其转换为 `String` 对象。

幸好，在必要时语言会自动把字符串字面量转换为一个 String 对象，也就是说你并不需要显示创建一个对象。JavaScript 社区中的大多数人都认为能使用文字形式时就不要使用构造函数形式。

```js
var strPrimitive = "I am a string";
console.log(strPrimitive.length); // 13
console.log(strPrimitive.charAt(3)); // "m"
```

使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为**引擎自动把字面量转换成 `String` 对象**，所以可以访问属性和方法。

同样的事也会发生在数值字面量上，如果使用类似 `42.359.toFixed(2)` 的方法，引擎会把 42 转换成 `new Number(42)`。对于布尔字面量来说也是如此。

**`null` 和 `undefined` 没有对应的构造形式，它们只有文字形式。相反，`Date` 只有构造，没有文字形式。**

对于 `Object`、`Array`、`Function` 和 `RegExp` （正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。在某些情况下，相比用文字形式创建对象，构造形式可以提供一些额外选项。由于这两种形式都可以创建对象，所以我们**首选更简单的文字形式**。建议只在需要那些额外选项时使用构造形式。

`Error` 对象很少在代码中显示创建，一般是在**抛出异常时被自动创建**。也可以使用 `new Error(..)` 这种构造形式来创建，不过一般来说用不着。

## 3.3 内容

对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。

需要强调的一点是，当我们说 “内容” 时，似乎在暗示这些值实际上被存储在对象内部，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并**不会**存在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像**指针**（从技术角度来说就是引用）一样，指向这些值真正的存储位置。

```js
var myObject = {
  a: 2
};
myObject.a; // 2
myObject["a"]; // 2
```

如果要访问 myObject 中 a 位置上的值，我们需要使用 `.` 操作符或者 `[]` 操作符。`.a` 语法通常被称为 **“属性访问”**，`["a"]` 语法通常被称为 **“键访问”**。实际上它们访问的是*同一个位置*，并且会返回相同的值 2，所以这两个术语是可以互换的。我们一般会使用最常见的术语 “属性访问”。

这两种语法的主要**区别**在于 `.` 操作符要求属性名满足标识符的命名规范，而 `[".."]` 语法可以接受任意 `UTF-8/Unicode` 字符串作为属性名。举例来说，如果要引用名称为 `"SuperFun!"` 的属性，那就必须使用 `["Super-Fun!"]` 语法访问，因为 `Super-Fun!` 并**不是一个有效的标识符属性名**。

此外，由于 `[".."]` 语法使用字符串来访问属性，所以可以在程序中构造这个字符串，比如说：

```js
var myObject = {
  a:2
};
var idx;
if (wantA) {
  idx = "a";
}
// 之后
console.log( myObject[idx] ); // 2
```

在对象中，**属性名永远都是字符串**。如果你使用 `string`（字面量）以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法：

```js
var myObject = { };

myObject[true] = "foo";
myObject[3] = "bar";
myObject[myObject] = "baz";

myObject["true"]; // "foo"
myObject["3"]; // "bar"
myObject["[object Object]"]; // "baz"
```

### 3.3.1 可计算属性名

如果你需要通过表达式来计算属性名，那么我们刚刚讲到的 `myObject[..]` 这种属性访问语法就可以派上用场了，如可以使用 `myObject[prefix + name]`。但是使用文字形式来声明对象时这样做是不行的。

ES6 增加了**可计算属性名**，可以在文字形式中使用 `[]` 包裹一个表达式来当作属性名：

```js
var prefix = "foo";

var myObject = {
  [prefix + "bar"]:"hello",
  [prefix + "baz"]: "world"
};

myObject["foobar"]; // hello
myObject["foobaz"]; // world
```

可计算属性名最常用的场景可能是 `ES6` 的符号（`Symbol`），不过简单来说，它们是一种新的基础数据类型，包含一个不透明且无法预测的值（从技术角度来说就是一个字符串）。一般来说你不会用到符号的实际值，所以通常你接触到的是**符号的名称**，比如 `Symbol.Something`（这个名字是我编的）：

```js
var myObject = {
  [Symbol.Something]: "hello world"
}
```

### 3.3.2 属性与方法

### 3.3.3 数组

### 3.3.4 复制对象

### 3.3.5 属性描述符

### 3.3.6 不变性

#### 1. 对象常量

#### 2. 禁止扩展

#### 3. 密封

#### 4. 冻结

### 3.3.7 `[[Get]]`

### 3.3.8 `[[Put]]`

### 3.3.9 `Getter` 和 `Setter`

### 3.3.10 存在性

#### 1. 枚举

## 3.4 遍历

## 3.5 小结
