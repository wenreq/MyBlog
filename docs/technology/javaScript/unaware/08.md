---
lang: zh-CN
title: 3. 对象
description: 对象
---

## 3.1 语法

对象可以通过两种形式定义：**声明**（文字）形式和**构造**形式。

对象的声明（文字）语法大概是这样的：

```js
var myObject = {
  key: value,
  // ...
}
```

构造形式大概是这样的：

```js
var myObject = new Object();
myObject.key = value;
```

构造形式和文字声明形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个键/值对，但是在构造形式中你必须逐个添加属性。

用上面的 “构造形式” 来创建对象是非常少见的，一般来说你会使用文字语法，绝大多数内置对象也是这样做的。

## 3.2 类型

对象是 JavaScript 的基础。在 JavaScript 中一共有六种主要类型（术语是“语言类型”）：

- string
- number
- boolean
- null
- undefined
- object

注意，简单基本类型（`string`、`boolean`、`number`、`null` 和 `undefined`）本身并不是对象。`null` 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 `null` 执行`typeof null` 时会返回字符串 "object"。实际上，`null` 本身是基本类型。（原理是这样的，不同的对象在底层都表示二进制，在JavaScript中二进制前三位都为 0 的话会被判断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回 “object”）。

有一种常见的错误说法是 “JavaScript 中万物皆是对象”，这显然是**错误**的。

实际上，JavaScript 中有许多特殊的**对象子类型**，我们可以称之为复杂基本类型。

函数就是对象的一个子类型（从技术角度来说就是 “可调用的的对象”）。JavaScript 中的函数是 “一等公民”，因为它们本质上和普通的对象一样（只是可以调用），所以可以像操作其他对象一样操作函数（比如当做另外一个函数的参数）。

数组也是对象的一种类型，具备一些额外的行为。数组中内容的组织方式比一般的对象要稍微复杂一些。

### 内置对象

JavaScript 中还有一些对象子类型，通常被称为**内置对象**。有些内置对象的名字看起来和简单基础类型一样，不过实际上它们的关系更复杂。

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error

这些内置对象从表现形式来说很像其他语言中的类型（type）或者类（class），比如 Java 中的 String 类。

但是在 JavaScript 中，它们实际上只是一些内置函数。这些内置函数可以当作**构造函数**（由 new 产生的函数调用）来使用，从而可以**构造一个对应子类型的新对象**。举例来说：

```js
var strPrimitive = "I am a string";
typeof strPrimitive; // "string"
strPrimitive instanceof String; // false

var strObject = new String( "I am a string" );
typeof strObject; // "object"
strObject instanceof String; // true

// 检查 sub-type 对象 
Object.prototype.toString.call(strObject); // [object String]
```

我们可以认为子类型在内部借用了 `Object` 中的 `toString()` 方法。从代码中可以看到，strObject 是由 `String` 构造函数创建的一个对象。

原始值 "I am a string" 并不是一个对象，它只是一个字面量，并且是一个不可变的值。如果要在这个字面量上执行一些**操作**，比如获取长度、访问其中某个字符等，那需要将其转换为 `String` 对象。

幸好，在必要时语言会自动把字符串字面量转换为一个 String 对象，也就是说你并不需要显示创建一个对象。JavaScript 社区中的大多数人都认为**能使用文字形式时就不要使用构造函数形式**。

```js
var strPrimitive = "I am a string";
console.log(strPrimitive.length); // 13
console.log(strPrimitive.charAt(3)); // "m"
```

使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为**引擎自动把字面量转换成 `String` 对象**，所以可以访问属性和方法。

同样的事也会发生在数值字面量上，如果使用类似 `42.359.toFixed(2)` 的方法，引擎会把 42 转换成 `new Number(42)`。对于布尔字面量来说也是如此。

**`null` 和 `undefined` 没有对应的构造形式，它们只有文字形式。相反，`Date` 只有构造，没有文字形式。**

对于 `Object`、`Array`、`Function` 和 `RegExp` （正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。在某些情况下，相比用文字形式创建对象，构造形式可以提供一些额外选项。由于这两种形式都可以创建对象，所以我们**首选更简单的文字形式**。建议只在需要那些额外选项时使用构造形式。

`Error` 对象很少在代码中显示创建，一般是在**抛出异常时被自动创建**。也可以使用 `new Error(..)` 这种构造形式来创建，不过一般来说用不着。

## 3.3 内容

对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。

需要强调的一点是，当我们说 “内容” 时，似乎在暗示这些值实际上被存储在对象内部，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并**不会**存在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像**指针**（从技术角度来说就是引用）一样，指向这些值真正的存储位置。

```js
var myObject = {
  a: 2
};
myObject.a; // 2
myObject["a"]; // 2
```

如果要访问 myObject 中 a 位置上的值，我们需要使用 `.` 操作符或者 `[]` 操作符。`.a` 语法通常被称为 **“属性访问”**，`["a"]` 语法通常被称为 **“键访问”**。实际上它们访问的是*同一个位置*，并且会返回相同的值 2，所以这两个术语是可以互换的。我们一般会使用最常见的术语 “属性访问”。

这两种语法的主要**区别**在于 `.` 操作符要求属性名满足标识符的命名规范，而 `[".."]` 语法可以接受任意 `UTF-8/Unicode` 字符串作为属性名。举例来说，如果要引用名称为 `"SuperFun!"` 的属性，那就必须使用 `["Super-Fun!"]` 语法访问，因为 `Super-Fun!` 并**不是一个有效的标识符属性名**。

此外，由于 `[".."]` 语法使用字符串来访问属性，所以可以在程序中构造这个字符串，比如说：

```js
var myObject = {
  a:2
};
var idx;
if (wantA) {
  idx = "a";
}
// 之后
console.log( myObject[idx] ); // 2
```

在对象中，**属性名永远都是字符串**。如果你使用 `string`（字面量）以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在**对象属性名中数字会被转换成字符串**，所以当心不要搞混对象和数组中数字的用法：

```js
var myObject = { };

myObject[true] = "foo";
myObject[3] = "bar";
myObject[myObject] = "baz";

myObject["true"]; // "foo"
myObject["3"]; // "bar"
myObject["[object Object]"]; // "baz"
```

### 3.3.1 可计算属性名

如果你需要通过表达式来计算属性名，那么我们刚刚讲到的 `myObject[..]` 这种属性访问语法就可以派上用场了，如可以使用 `myObject[prefix + name]`。但是使用文字形式来声明对象时这样做是不行的。

ES6 增加了**可计算属性名**，可以在文字形式中使用 `[]` 包裹一个表达式来当作属性名：

```js
var prefix = "foo";

var myObject = {
  [prefix + "bar"]:"hello",
  [prefix + "baz"]: "world"
};

myObject["foobar"]; // hello
myObject["foobaz"]; // world
```

可计算属性名最常用的场景可能是 `ES6` 的符号（`Symbol`），不过简单来说，它们是一种新的基础数据类型，包含一个不透明且无法预测的值（从技术角度来说就是一个字符串）。一般来说你不会用到符号的实际值，所以通常你接触到的是**符号的名称**，比如 `Symbol.Something`（这个名字是我编的）：

```js
var myObject = {
  [Symbol.Something]: "hello world"
}
```

### 3.3.2 属性与方法

如果**访问的对象属性是一个函数**，有些开发者喜欢使用不一样的叫法以作区分。由于函数很容易被认为是属于某个对象，在其他语言中，属于对象的函数通常被称为 “方法”，因此把 “属于访问” 说成是 “方法访问” 也就不奇怪了。

有意思的是，JavaScript 的语法规范也做出了同样的区分。

从技术角度来说，函数永远不会 “属于” 一个对象，所以把对象内部引用的函数称为 “方法” 似乎有点不妥。

确实，有些函数具有 `this` 引用，有时候这些 `this` 确实会指向调用位置的对象引用。但是这种用法从本质上来说并没有把一个函数变成一个 “方法”，因为 **`this` 是在运行时根据调用位置动态绑定的**，所以函数和对象的关系最多也只能说是**间接关系**。

无论返回值是什么类型，每次访问对象的属性就是属性访问。如果属性访问返回的是一个函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别（除了可能发生的隐式绑定 `this`，就像我们刚才提到的）。

举例来说：

```js
function foo() {
  console.log( "foo" );
}

var someFoo = foo; // 对 foo 的变量引用
var myObject = {
  someFoo: foo
};

foo; // function foo(){..}
someFoo; // function foo(){..}
myObject.someFoo; // function foo(){..}
```

`someFoo` 和 `myObject.someFoo` 只是对于同一个函数的不同引用，并不能说明这个函数是特别的或者 “属于” 某个对象。如果 `foo()` 定义时在内部有一个 `this` 引用，那这两个函数引用的唯一区别就是 `myObject.someFoo` 中的 `this` 会被隐式绑定到一个对象。无论哪种引用形式都不能称之为 “方法”。

最保险的说法可能是，“函数” 和 “方法”在 JavaScript 中是可以互换的。

即使你在对象的文字形式中声明一个函数表达式，这个函数也不会 “属于” 这个对象——它们只是**对于相同函数对象的多个引用**。

```js
var myObject = {
  foo: function() {
    console.log( "foo" );
  }
};
var someFoo = myObject.foo;
someFoo; // function foo(){..}
myObject.foo; // function foo(){..}
```

### 3.3.3 数组

数组也支持 `[]` 访问形式，不过就像我们之前提到过的，数组有一套更加结构化的值存储机制（不过仍然不限制值的类型）。数组期望的是数值下标，也就是说值存储的位置（通常被称为索引）是非负整数。

```js
var myArray = [ "foo", 42, "bar" ];
myArray.length; // 3
myArray[0]; // "foo"
myArray[2]; // "bar"
```

数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：

```js
var myArray = [ "foo", 42, "bar" ];
myArray.baz = "baz";
myArray.length; // 3
myArray.baz; // "baz"
```

可以看到虽然添加了命名属性（无论是通过 `.` 语法还是 `[]` 语法），数组的 `length` 值并未发生变化。

你完全可以把数组当做一个普通的键/值对象来使用，并且不添加任何数组索引，但是这并不是一个好主意。数组和普通的对象都根据其的对应的行为用途进行了优化，所以做好只**用对象来存储键/值对**，只**用数组来存储数值下标/值对**。

注意：如果你试图向数组添加一个属性，但是属性名 “看起来” 像一个数字，那它会变成一个数值下标（因此会修改数组的内容而不是添加一个属性）：

```js
var myArray = [ "foo", 42, "bar" ];
myArray["3"] = "baz";
myArray.length; // 4
myArray[3]; // "baz"
```

### 3.3.4 复制对象

对于 `JSON` 安全（也就是说可以被序列化为一个 `JSON` 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）的对象来说，有一种巧妙的复制方法：

`var newObj = JSON.parse(JSON. stringify(someObj));`

当然，这种方法需要保证对象是 `JSON` 安全的，所以只适用于部分情况。

相比深复制，浅复制非常易懂并且问题要少得多，所以 `ES6` 定义了 `Object.assign(..)` 方法来实现浅复制。`Object.assign(..)` 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的**所有可枚举的自有键**（owned key，很快会介绍）并把它们复制（使用 = 操作符赋值）到目标对象，最后返回目标对象，就像这样：

```js
function anotherFunction() { /*..*/ }
var anotherObject = {
  c: true
};
var anotherArray = [];
var myObject = {
  a: 2,
  b: anotherObject, // 引用，不是复本！
  c: anotherArray, // 另一个引用！
  d: anotherFunction
}; 
anotherArray.push( anotherObject, myObject );

var newObj = Object.assign( {}, myObject );
newObj.a; // 2
newObj.b === anotherObject; // true
newObj.c === anotherArray; // true
newObj.d === anotherFunction; // true
```

下一节会介绍 “属性描述符” 以及 `Object.defineProperty(..)` 的用法。但是需要注意的一点是，由于 `Object.assign(..)` 就是使用 `=` 操作符来赋值，所以源对象属性的一些特性（比如 `writable`）不会被复制到目标对象。

### 3.3.5 属性描述符

在 `ES5` 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。

但是从 ES5 开始，所有的属性都具备了属性描述符。

```js
var myObject = {
  a: 2
};
Object.getOwnPropertyDescriptor( myObject, "a" );
// {
// value: 2,
// writable: true,
// enumerable: true,
// configurable: true
// }
```

如你所见，这个普通的对象属性对应的属性描述符（也被称为 “数据描述符”，因为它只保存一个数据值）可不仅仅只是一个 2。它还包含另外三个特性：`writable`（可写）、`enumerable`（可枚举）和 `configurable`（可配置）。

在创建普通属性时属性描述符会使用默认值，我们也可以使用 `Object.defineProperty(..)` 来添加一个新属性或者修改一个已有属性（如果它是 `configurable`）并对特性进行设置。

```js
var myObject = {};
Object.defineProperty( myObject, "a", {
  value: 2,
  writable: true,
  configurable: true,
  enumerable: true
});
myObject.a; // 2
```

我们使用 `defineProperty(..)` 给 `myObject` 添加了一个普通的属性并显式指定了一些特性。然而，一般来说你不会使用这种方式，除非你想**修改属性描述符**。

#### 1. Writable

`writable` 决定是否可以**修改属性的值**。

```js
var myObject = {};
Object.defineProperty( myObject, "a", {
  value: 2,
  writable: false, // 不可写！
  configurable: true,
  enumerable: true
});
myObject.a = 3;
myObject.a; // 2
```

如你所见，我们对于属性值的修改**静默失败**（silently failed）了。如果在严格模式下，这种方法会出错：

```js
"use strict";

var myObject = {};
Object.defineProperty( myObject, "a", {
  value: 2,
  writable: false, // 不可写！
  configurable: true,
  enumerable: true
});
myObject.a = 3; // TypeError
```

`TypeError` 错误表示我们无法修改一个不可写的属性。

之后我们会介绍 `getter` 和 `setter`，不过简单来说，你可以把 `writable:false` 看作是属性不可改变，相当于你定义了一个空操作 `setter`。严格来说，如果要和 `writable:false` 一致的话，你的 `setter` 被调用时应当抛出一个 `TypeError` 错误。

#### 2. Configurable

只要属性是可配置的，就可以使用 `defineProperty(..)` 方法来**修改属性描述符**：

```js
var myObject = {
  a:2
};
myObject.a = 3;
myObject.a; // 3
Object.defineProperty( myObject, "a", {
  value: 4,
  writable: true,
  configurable: false, // 不可配置！
  enumerable: true
});
myObject.a; // 4
myObject.a = 5;
myObject.a; // 5
Object.defineProperty( myObject, "a", {
 value: 6,
 writable: true,
 configurable: true,
 enumerable: true
}); // TypeError
```

最后一个 `defineProperty(..)` 会产生一个 `TypeError` 错误，不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错。注意：如你所见，把 `configurable` 修改成 `false` 是**单向操作，无法撤销！**

要注意有一个小小的例外：即便属性是 `configurable:false`，我们还是可以把 `writable` 的状态由 `true` 改为 `false`，但是无法由 `false` 改为 `true`。

除了无法修改，`configurable:false` 还会**禁止删除这个属性**：

```js
var myObject = {
  a:2
};
myObject.a; // 2
delete myObject.a;
myObject.a; // undefined
Object.defineProperty( myObject, "a", {
  value: 2,
  writable: true,
  configurable: false,
  enumerable: true
});
myObject.a; // 2
delete myObject.a;
myObject.a; // 2
```

如你所见，最后一个 `delete` 语句（静默）失败了，因为属性是不可配置的。

不要把 `delete` 看作一个释放内存的工具，它就是一个删除对象属性的操作，仅此而已。

#### 3. Enumerable

这里我们要介绍的最后一个属性描述符（还有两个，我们会在介绍 `getter` 和 `setter` 时提到）是 enumerable。

从名字就可以看出，这个描述符控制的是**属性是否会出现在对象的属性枚举中**，比如说 `for..in` 循环。如果把 `enumerable` 设置成 `false`，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 `true` 就会让它出现在枚举中。

用户定义的所有的普通属性**默认都是 `enumerable:true`**，这通常就是你想要的。但是如果你不希望某些特殊属性出现在枚举中，那就把它设置成 `enumerable:false`。

### 3.3.6 不变性

有时候你会希望属性或者对象是不可改变（无论有意还是无意）的，在 `ES5` 中可以通过很多种方法来实现。

#### 1. 对象常量

结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、重定义或者删除）：

```js
var myObject = {};
Object.defineProperty( myObject, "FAVORITE_NUMBER", {
  value: 42,
  writable: false,
  configurable: false
});
```

#### 2. 禁止扩展

如果你想**禁止一个对象添加新属性并且保留已有属性**，可以使用 `Object.preventExtensions(..)`：

```js
var myObject = {
 a: 2
};
Object.preventExtensions( myObject );
myObject.b = 3;
myObject.b; // undefined
```

在非严格模式下，创建属性 `b` 会静默失败。在严格模式下，将会抛出 `TypeError` 错误。

#### 3. 密封

`Object.seal(..)` 会创建一个 “密封” 的对象，这个方法实际上会在一个现有对象上调用 `Object.preventExtensions(..)` 并把所有属性标记为 `configurable: false`。

所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）。

#### 4. 冻结

`Object.freeze(..)` 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 `Object.seal(..)` 并把所有 “数据访问” 属性标记为 `writable:false`，这样就无法修改它们的值。

这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（不过就像我们之前说过的，这个对象引用的其他对象是不受影响的）。

你可以 “深度冻结” 一个对象，具体方法为，首先在这个对象上调用 `Object.freeze(..)`，然后遍历它引用的所有对象并在这些对象上调用 `Object.freeze(..)`。但是一定要小心，因为这样做有可能会在无意中冻结其他（共享）对象。

### 3.3.7 `[[Get]]`

### 3.3.8 `[[Put]]`

### 3.3.9 `Getter` 和 `Setter`

### 3.3.10 存在性

#### 1. 枚举

## 3.4 遍历

## 3.5 小结
