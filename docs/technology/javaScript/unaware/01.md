---
lang: zh-CN
title: 1. 作用域是什么
description: 作用域是什么
---

将变量引入程序会引起几个很有意思的问题，也正是我们将要讨论的：这些变量住在哪里？换句话说，***它们储存在哪里？*** 最重要的是，***程序需要时如何找到它们？***

这些问题说明需要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。这套规则被称为作用域。

但是，究竟在哪里而且怎样设置这些作用域的规则呢？

## 1.1 编译原理

尽管通常将 `JavaScript` 归类为 “动态” 或 “解释执行” 语言，但事实上它是一门编译语言。但与传统的编译语言不同，它**不是**提前编译的，编译结果也不能在分布式系统中进行移植。

在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为**编译**。

- 分词/词法分析（Tokenizing/Lexing）

   这个过程会**将由字符组成的字符串分解成有意义的代码块**，这些代码块被称为**词法单元**（token）。例如，考虑程序 `var a = 2;`。这段程序通常会被分解成为下面这些词法单元：`var`、`a`、`=`、`2` 、`;`。

- 解析/语法分析（Parsing）

   这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了**程序语法结构的树**。这个树被称为**抽象语法树**（Abstract Syntax Tree，AST）。

- 代码生成

   将 `AST` 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。

   抛开具体细节，简单来说就是有某种方法可以将 `var a = 2;` 的 `AST` 转化为**一组机器指令**，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。

   **引擎可以根据需要，创建并储存变量。**

## 1.2 理解作用域

我们学习作用域的方式是将这个过程模拟成几个人物之间的对话。那么，由谁进行这场对话呢？

### 1.2.1 演员表

首先介绍将要参与到对程序 `var a = 2;` 进行处理的过程中的演员们，这样才能理解接下来将要听到的对话。

- 引擎（从头到尾负责整个 `JavaScript` **程序的编译及执行过程**。）
- 编译器（引擎的好朋友之一，负责**语法分析及代码生成**等脏活累活。）
- 作用域（引擎的另一位好朋友，负责**收集并维护**由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。）

### 1.2.2 对话

当你看见 `var a = 2;` 这段程序时，很可能认为这是一句声明。但我们的新朋友引擎却不这么看。事实上，引擎认为这里有两个完全不同的声明，一个由编译器在**编译时处理**，另一个则由引擎在**运行时处理**。

下面我们将 `var a = 2;` 分解，看看引擎和它的朋友们是如何协同工作的。

编译器首先会**将这段程序分解成词法单元**，然后**将词法单元解析成一个树结构**。但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内存，将其命名为 a，然后将值 2 保存进这个变量。” 然而，这并不完全正确。

事实上编译器会进行如下处理。

1. 遇到 `var a`，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 `a`。
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 `a = 2` 这个赋值操作。引擎运行时会首先询问作用域，在当前作用域集合中是否存在一个叫做 `a` 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

如果引擎最终找到了 `a` 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！

**总结：** 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

### 1.2.3 编译器有话说

引擎会为变量 `a` 进行 `LHS` 查询。另外一个查找的类型叫作 `RHS`。“L” 和 “R” 的含义，它们分别代表左侧和右侧。什么东西的左侧和右侧？是**一个赋值操作的左侧和右侧**。

换句话说，当变量出现在赋值操作的左侧时进行 `LHS` 查询，出现在右侧时进行 `RHS` 查询。

讲的更准确一点，`RHS` 查询与简单地查找某个变量的值别无二至，而 `LHS` 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，`RHS` 并不是真正意义上的 “赋值操作的右侧”，更准确地说是 “非左侧”。

你可以将 `RHS` 理解成 `retrieve his source value`（取到它的源值）。这意味着 “得到某某的值”。

LHS 和 RHS 的含义是 “赋值操作的左侧或右侧” 并不一定意味着就是 “=赋值操作符的左侧或右侧” 。赋值操作还有其他几种形式，因此在概念上最好将其理解为 “赋值操作的目标是谁（LHS）” 以及 “谁是赋值操作的源头（RHS）”。

### 1.2.4 引擎和作用域的对话

```js
function foo(a) {
 console.log( a ); // 2
}
foo( 2 );
```

让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。

```txt
引擎：我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗？
作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。
引擎：哥们太够意思了！好吧，我来执行一下 foo。
引擎：作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗？
作用域：这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。
引擎：大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。
引擎：哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗？
作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。
给你。
引擎：么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。
引擎：哥们，能帮我再找一下对 a 的 RHS 引用吗？虽然我记得它，但想再确认一次。
作用域：放心吧，这个变量没有变动过，拿走，不谢。
引擎：真棒。我来把 a 的值，也就是 2，传递进 log(..)。
……
```

## 1.3 作用域嵌套

我们说过，**作用域是根据名称查找变量的一套规则**。实际情况中，通常需要同时顾及几个作用域。

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，**引擎**就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是**全局作用域**）为止。

## 1.4 异常

如果 `RHS` 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 `ReferenceError`异常。值得注意的是，`ReferenceError` 是非常重要的异常类型。

相较之下，当引擎执行 `LHS` 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。**严格模式禁止自动或隐式地创建全局变量。**

试图对一个非函数类型的值进行函数调用，或者引用 `null` 或 `undefined` 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 `TypeError`。

`ReferenceError` 同作用域判别失败相关，而 `TypeError` 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

## 1.5 小结

作用域是一套规则，**用于确定在何处以及如何查找变量（标识符）**。如果查找的目的是对变量进行**赋值**，那么就会使用 `LHS` 查询；如果目的是**获取**变量的值，就会使用 `RHS` 查询。

赋值操作符会导致 `LHS` 查询。= 操作符或调用函数时传入参数的操作符都会导致关联作用域的赋值操作。

`JavaScript` 引擎首先会在代码执行前对其进行编译，在这个过程中，像 `var a = 2;` 这样的声明会被分解成两个独立的步骤：

1. 首先，`var a` 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
2. 接下来，`a = 2` 会查询（LHS 查询）变量 `a` 并对其进行赋值。

`LHS` 和 `RHS` 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论找到或没找到都将停止。

不成功的 `RHS` 引用会导致抛出 `ReferenceError` 异常。不成功的 `LHS` 引用会导致自动隐式地创建一个全局变量（在非严格模式下），该变量使用 `LHS` 引用的目标作为标识符，或者抛出 `ReferenceError` 异常（在严格模式下）。
