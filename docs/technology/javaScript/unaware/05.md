---
lang: zh-CN
title: 5. 作用域闭包
description: 作用域闭包
---

## 5.1 启示

JavaScript 中闭包无处不在，你只需要能够识别并拥抱它。

**闭包是基于词法作用域书写代码时所产生的自然结果**，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。

## 5.2 实质问题

下面是直接了当的定义，你需要掌握它才能理解和识别闭包：

***当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。***

下面用一些代码来解释这个定义。

```js
function foo() {
  var a = 2;
  function bar() {
    console.log(a); // 2
  }
  bar();
}
foo();
```

这段代码看起来和嵌套作用域中的示例代码很相似。基于**词法作用域的查找规则**，函数 `bar()` 可以访问外部作用域中的变量 `a`（这个例子中的是一个 `RHS` 引用查询）。

这是闭包吗？

技术上来讲，也许是。但根据前面的定义，确切地说不是。我认为最准确地用来解释 `bar()` 对 `a` 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但却是非常重要的一部分！）

下面我们来看一段代码，清晰地展示了闭包：

```js
function foo() {
  var a = 2;
  function bar() {
    console.log( a );
  }
  return bar;
}
var baz = foo();
baz(); // 2 —— 朋友，这就是闭包的效果。
```

函数 `bar()` 的词法作用域能够访问 `foo()` 的内部作用域。然后我们将 `bar()` 函数本身当作一个值类型进行传递。在这个例子中，我们将 `bar` 所引用的函数对象本身当作返回值。

在 `foo()` 执行后，其返回值（也就是内部的 `bar()` 函数）赋值给变量 `baz` 并调用 `baz()`，实际上只是通过不同的标识符引用调用了内部的函数 `bar()`。

`bar()` 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。

在 `foo()` 执行后，通常会期待 `foo()` 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 `foo()` 的内容不会再被使用，所以很自然地会考虑对其进行回收。

而闭包的 “神奇” 之处正是可以阻止这件事情的发生。**事实上内部作用域依然存在，因此没有被回收。**谁在使用这个内部作用域？原来是 `bar()` 本身在使用。

拜 `bar()` 所声明的位置所赐，它拥有涵盖 `foo()` 内部作用域的闭包，使得该作用域能够一直存活，以供 `bar()` 在之后任何时间进行引用。

**`bar()` 依然持有对该作用域的引用，而这个引用就叫作闭包。**

## 5.3 现在我懂了

前面的代码片段有点死板，并且为了解释如何使用闭包而人为地在结构上进行了修饰。但我保证闭包绝不仅仅是一个好玩的玩具。你已经写过的代码中一定到处都是闭包的身影。现在让我们来搞懂这个事实。

```js
function wait(message) {
  setTimeout(function timer() {
    console.log( message )
  }, 1000);
}
wait("Hello World!")
```

将一个内部函数（名为 `timer`）传递给 `setTimeout(..)`。`timer` 具有涵盖 `wait(..)` 作用域的闭包，因此还保有对变量 `message` 的引用。

`wait(..)` 执行 1000 毫秒后，它的内部作用域并不会消失，`timer` 函数依然保有 `wait(..)`作用域的闭包。

在引擎内部，内置的工具函数 `setTimeout(..)` 持有对一个参数的引用，这个参数也许叫作`fn` 或者 `func`，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 `timer` 函数，而词法作用域在这个过程中保持完整。

这就是闭包。

在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！

```js
var a = 2;
(function IIFE() {
  console.log( a );
})();
```

严格来讲 IIFE 它并不是闭包。`a` 是通过普通的词法作用域查找而非闭包被发现的。

## 5.4 循环和闭包

```js
for (var i = 1; i <= 5; i++) {
  setTimeout( function timer() { // 函数共享一个 i 的引用
    console.log( i );
  }, i*1000 ); // 6 6 6 6 6
}
```

这段代码在运行时会以每秒一次的频率输出五次 6。延迟**函数的回调会在循环结束时才执行**。事实上，当定时器运行时即使每个迭代中执行的是 `setTimeout(.., 0)`，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。

缺陷是我们试图假设循环中的每个迭代在运行时都会给自己 “捕获” 一个 `i` 的副本。但是根据作用域的工作原理，实际情况时尽管循环中的五个函数是在各个迭代中分别定义的，但是**它们都被封闭在一个共享的全局作用域中**，因此实际上只有一个 `i`。

下面回到正题。缺陷是什么？我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。

第 3 章介绍过，`IIFE` 会通过声明并立即执行一个函数来创建作用域。

```js
for (var i = 1; i <= 5; i++) {
  (function () {
    setTimeout( function timer() {
      console.log( i );
    }, i * 1000);
  })()
}
```

`IIFE` 只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。

它需要有自己的变量，用来在*每个迭代中存储 `i` 的值*：

```js
for(var i = 0; i <= 5; i++) {
  (function (){
    var j = i;
    setTimeout( function timer() {
      console.log( j );
    }, j * 1000);
  })()
}
```

行了！它能正常工作了！。

可以对这段代码进行一些改进：

```js
for(var i = 0; i <= 5; i++) {
  (function (j){
    setTimeout( function timer() {
      console.log( j );
    }, j * 1000);
  })( i )
}
```

当然，这些 `IIFE` 也不过就是函数，因此我们可以将 `i` 传递进去，如果愿意的话可以将变量名定为 `j`，当然也可以还叫作 `i`。无论如何这段代码现在可以工作了。

在迭代内使用 `IIFE` 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。

问题解决啦！

### 重返块作用域

我们使用 `IIFE` 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。

每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。

```js
for (let i=1; i<=5; i++) {
  setTimeout( function timer() {
    console.log( i );
  }, i*1000 );
}
```

## 5.5 模块

```js
function CoolModule() {
  var something = "cool";
  var another = [1, 2, 3];
  function doSomething() {
    console.log( something );
  }
  function doAnother() {
    console.log( another.join( " ! " ) );
  }
  return {
    doSomething: doSomething,
    doAnother: doAnother
  };
}

var foo = CoolModule();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

这个模式在 JavaScript 中被成为模块。最常见的实现模块模式的方法通常被称为**模块暴露**，这里展示的是其变体。

我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的**公共** API。

从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函数。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公共 API，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属性）。

如果要更简单的描述，模块模式需要具备两个必要条件。

1. 必须有外部的封装函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并**不是**真正的模块。

上一个示例代码中有一个叫作 `CoolModule()` 的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实现**单例模式**：

```js
var foo = (function CoolModule() {
  var something = "cool";
  var another = [1, 2, 3];
  function doSomething() {
    console.log(something);
  }
  function doAnother() {
    console.log(another.join(" ! "));
  }
  return {
    doSomething,
    doAnother
  }
})();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

### 5.5.1 现代的模块机制

调用包装了函数定义的包装函数，并且将返回值作为该模块的 API。

换句话说，模块就是模块，即使在它们外层加上一个友好的包装工具也不会发生任何变化。

### 5.5.2 未来的模块机制

ES6 模块 API 是**静态的**。可以在**编译期检查**对导入模块的 API 成员的引用是否真实存在。如果 API 引用并不存在，编译器会在编译时就抛出 “早期” 错误，而不会等到运行期再动态解析（并且报错）。

ES6 的模块没有 “行内” 格式，必须被定义在独立的文件中（一个文件一个模块）。浏器或引擎有一个默认的 “模块加载器” 可以**在导入模块时同步地加载模块文件**。

`import` 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上。`module` 会将整个模块的 API 导入并绑定到一个变量上。`export` 会将当前模块的一个标识符（变量、函数）导出为公共 API。这些操作可以在模块定义中根据需要使用任意多次。

**模块文件**中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。

## 5.6 小结

闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够达到那里。但事实上它只是一个普通且明显的事实，那就是我们在词法作用域的环境下写代码，而其中的函数也是值，可以随意传来传去。

当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这是就产生了闭包。

如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现**模块**等模式。

模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。

现在我们会发现代码中到处都有闭包存在，并且我们能够识别闭包然后用它来做一些有用的事！
