---
lang: zh-CN
title: 4. 提升
description: 声明提升
---

任何声明在某个作用域内的变量，都将附属于这个作用域。但是作用域同其中的**变量声明出现的位置**有某种微妙的联系。

## 4.1 先有鸡还是先有蛋

直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有一种特殊情况会导致这个假设是错误的。

```js
a = 2;
var a;
console.log( a ); // 2
```

```js
console.log( a ); // undefined
var a = 2;
```

那么到底发生了什么？看起来我们面对的是一个先有鸡还是先有蛋的问题。到底是声明（蛋）在前，还是赋值（鸡）在前？

## 4.2 编译器再度来袭

***引擎会在解释 `JavaScript` 代码之前首先对其进行编译。*** 编译阶段中的一部分工作就是**找到所有的声明**，并用合适的作用域将它们关联起来。

因此，正确的思考是，包括**变量和函数在内的都会在任何代码执行前首先被处理。**

当你看到 `var a = 2;` 时，可能会认为这是一个声明。但 `JavaScript` 实际上会将其看成两个声明：`var a;` 和 `a = 2;`。第一个定义声明是在**编译阶段**进行的。第二个赋值声明会被留在原地等待**执行阶段**。

这个过程就好像变量和函数**声明**从它们在代码中出现的位置被 “移动” 到了最上面。这个过程就叫作**提升**。

换句话说，先有蛋（声明）后有鸡（赋值）。

可以看到，函数声明会被提升，但是函数表达式却不会被提升。

```js
foo();
function foo() {
  var a;
  console.log( a ); // undefined
  a = 2;
}

foo(); // 不是 ReferenceError, 而是 TypeError!
var foo = function bar() {
  // ...
};
```

这段程序中的变量标识符 `foo()` 被提升并分配给所在作用域，但是 `foo` 此时并没有赋值，`foo()` 由于对 `undefined` 值进行函数调用而导致非法操作，因此抛出 `TypeError` 异常。

## 4.3 函数优化

函数声明和变量声明都会被提升。但是一个值得注意的细节是：**函数会首先被提升，然后才是变量。**

```js
foo(); // 1
var foo;
function foo() {
  console.log( 1 );
}
foo = function() {
  console.log( 2 );
};
```

会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：

```js
function foo() {
  console.log( 1 );
}
foo(); // 1
foo = function() {
  console.log( 2 );
};
```

注意，`var foo` 尽管出现在 `function foo()...` 的声明之前，但它是重复的声明（因此被忽略了），因为**函数声明会被提升到普通变量之前。**

尽管重复的 `var` 声明会被忽略掉，但出现在 ***后面的函数声明还是可以覆盖前面的***。

```js
foo(); // 3
function foo() {
  console.log( 1 );
}
var foo = function() {
  console.log( 2 );
};
function foo() {
  console.log( 3 );
}
```

## 4.4 小结

我们习惯将 `var a = 2;` 看做一个声明，而实际上 `JavaScript` 引擎并不这么认为。它将 `var a` 和 `a = 2` 当做两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。

这意味着无论作用域中的声明出现在声明地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被 “移动” 到各自作用域的最顶端，这个过程被称为提升。

声明本身会被提升，而包括函数表达式的赋值在内的赋值操作符并***不会***提升。

要注意避免重复声明，特别是当普通函数的 `var` 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！
