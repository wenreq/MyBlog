---
lang: zh-CN
title: 08. 函数
---

### 1.箭头函数

简洁；只有一个参数时，可以省略括号；一行表达式代码，可以省略大括号。

不能使用 `arguments`、`super`和`new target`，不能做构造函数。

### 2.函数名

函数名就是指向函数的指针，可以有多个名称。

函数对象都会暴露一个只读的 `name` 属性。

### 3.理解参数

`arguments` 对象是一个类数组对象（但不是Array的实例）。

可以使用**中括号**语法访问其中的元素（`arguments[0]`），可以访问`arguments.length`属性来确定传进来的参数个数。

`arguments`对象的值会自动同步到对应的命名参数。它们在内存中是分开的，只不过会保持同步而已。

在严格模式下，在函数中尝试重写 `arguments` 对象会导致语法错误。

### 4.没有重载

在 ECMAScript 中定义两个同名函数，则**后定义的会覆盖先定义的**。

### 5.默认参数

参数后面用 `=`；`arguments` 对象的值不反应参数的默认值，只反映**传给函数的参数**。也可以使用调用函数返回值。

箭头函数也可以使用默认参数。

### 6.参数扩展和收集

#### 扩展参数

对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将迭代对象拆分，并将迭代返回的每个值单独传入。

`arguments`对象只是消费扩展操作符的一种方式。在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数。

```js
function getProduct(a, b, c = 1) {
  return a * b * c;
}
let getSum = (a, b, c = 0) => {
  return a + b + c;
}
console.log(getProduct(...[1,2])); // 2
console.log(getProduct(...[1,2,3])); // 6
console.log(getProduct(...[1,2,3,4])); // 6
console.log(getSum(...[0,1])); // 1
console.log(getSum(...[0,1,2])); // 3
console.log(getSum(...[0,1,2,3])); // 3
```

#### 收集参数

在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。

```js
// 不可以
function getProduct(...values, lastValue) {}
// 可以
function ignoreFirst(firstValue, ...values) {
  console.log(values);
}
ignoreFirst(); // []
ignoreFirst(1); // []
ignoreFirst(1,2); // [2]
ignoreFirst(1,2,3); // [2, 3]
```

### 7.函数声明与函数表达式

`JavaScript`引擎在任何代码执行前，会先读取函数声明，并在执行上下文中生成函数定义。

```js
// 没问题
console.log(sum(10, 10));
function sum(num1, num2) {
 return num1 + num2;
}
```

函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。

```js
// 会出错
console.log(sum(10, 10));
let sum = function(num1, num2) {
 return num1 + num2;
};
```

**函数声明提升**，在执行代码时，`JavaScript`引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部。所以即使函数定义出现在调用它们的代码之后，也不会报错，而函数表达式则不行。

### 8.函数作为值

在一个函数中返回另一个函数。第一个参数应该是函数，第二个参数应该是要传给这个函数的值。

```js
function callSomeFunction(someFunction, someArgument) {
  return someFunction(someArgument);
}
```

### 9.内部函数

`ECMAScript5`中，函数内部存在两个特殊的对象：`arguments`和`this`。`ECMAScript6`又新增了`new.target`属性。

#### arguments

类数组对象，包含调用函数时传入的所有参数。

`callee`属性，是一个指向`arguments`对象所在函数的指针。

`arguments.callee`是一个指向正在执行的函数的指针，因此可以在函数内部递归调用。

#### this

`this`引用的是把函数当成方法调用的上下文对象。

- 作为**纯函数**调用时，`this`指向`window`.
- 作为**对象方法**调用，`this`指向这个对象。
- **箭头函数**中，`this`引用的是定义箭头函数的上下文。

#### caller

这个属性引用的是**调用当前函数**的函数。如果在全局作用域中调用的则为`null`。

#### new.target

**检测函数是否使用`new`关键字调用。**

如果函数是**正常调用**的，则 `new target` 的值是 `undefined`。

如果是使用 `new` 关键字调用的，则 `new target` 将应用被调用的构造函数。

### 10.函数属性与方法

函数都有两个属性：`length` 和 `prototype`。

- `length` 属性保存函数定义的**命名参数的个数**。
- `prototype` 是保存引用类型所有实例的地方，`toString()`、`valueOf()`等方法实际上都保存在`prototype`上，进而由所有实例共享。`prototype`属性是**不可枚举**的，因此使用**for-in**循环不会返回这个属性。

函数还有两个方法：`apply()`和`call()`。

这两个方法都会以**指定的`this`值**来调用函数，即会**设置调用函数是函数体内`this`对象的值**。

- `apply()`方法接受两个参数：函数内`this`的值和一个**参数数组**。
- `call()`方法：第一个参数`this`值，剩下的要传给被调用函数的参数则是**逐个传递**的，一个一个地列出来。

`apply()`和`call()`真正强大的地方是**控制函数调用上下文**，**即函数体内this值的能力**。

`bind()`方法会创建一个**新的函数实例**，其`this`值会被绑定到传给`bind()`的对象。

### 11.函数表达式

定义函数有两种方式：**函数声明**和**函数表达式**。

函数声明的关键点是**函数声明提升**，**javaScript**引擎会**先读取函数声明，再执行代码**。

函数表达式看起来像一个普通的变量定义和赋值，这样创建的函数叫**匿名函数**，因为`function`关键字后面没有标识。未赋值给其他变量的匿名函数的 `name` 属性是空字符串。

### 12.递归

一个函数通过名称调用自己。

`arguments.callee`就是**一个指向正在执行的函数的指针**，因此可以在函数内部递归调用。

严格模式下，代码不能访问arguments.callee的，因为访问会出错。此时，可以使用**命名函数表达式**达到目的。

```js
const factorial = (function f(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * f(num - 1);
  }
});
```

### 13.尾调用优化

`ECMAScript6`新增了一项内存管理优化机制，让`JavaScript`引擎**在满足条件时可以重用调用帧**。

这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。

```js
function outerFunction() { 
  return innerFunction(); // 尾调用 
}
```

无论多少次嵌套函数，都只有一个栈帧。ES6尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。

### 14.闭包

内部函数的作用域链包含外部函数的作用域。

函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过闭包就不一样。**内部函数引用着外部函数的活动对象**，内存不会被回收。

把执行完毕的变量设置为`null`会解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。

### 15.立即调用的函数表达式

立即调用的函数表达式（`IIFE，Immediately Invoked Function Expression`）。

使用`IIFE`可以**模拟块级作用域**。`ECMAScript 6`之后可以使用`let`创建块级作用域变量。

```js
(function() {
  // 块级作用域
})();
```

### 16.私有变量

任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。

私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。

### 小结

函数是 `JavaScript` 编程中最有用也最通用的工具。`ECMAScript 6` 新增了更加强大的语法特性，从而让开发者更有效地使用函数。

- 函数表达式与函数声明不一样的。函数声明要求写出函数名称，而函数表达式并不需要。没名称的函数表达式也被称为匿名函数。
- `ES6` 新增了类似于函数表达式的箭头函数语法，但两者也有一些重要的区别。
- `JavaScript` 中函数定义与调用时参数及其灵活。`arguments`对象，以及 `ES6` 新增的扩展操作符，可以实现函数定义和调用的完全动态化。
- 函数内部也暴露了很多对象和引用，涵盖了函数被谁调用、使用什么调用，以及调用时传入了什么参数的等信息。
- `JavaScript` 引擎可以优化符合尾调用条件的函数，以节省栈空间。
- 闭包的作用域中包含自己的一个变量对象，然后是包含函数的变量对象，直到全局上下文的变量对象。
- 通常，函数作用域及其中的所有变量在函数执行完毕后被销毁。
- 闭包在被函数返回之后，其作用域会一直在内存中，知道闭包被销毁。
- 函数可以在创建之后立即调用，执行其中代码之后却不留下对函数的引用。
- 立即调用的函数表达式如果不在包含作用域中将返回赋值给一个变量，则其包含的所有变量都会被销毁。
- 虽然 `JavaScript` 没有私有对象属性的概念，但可以使用闭包实现公共方法，访问位于包含作用域中定义的变量。
- 可以访问私有变量的公共方法叫做特权方法。
- 特权方法可以使用构造函数或原型模式通过自定义类型中实现，也可以使用模块模式或模块增强模式在单例对象上实现。
