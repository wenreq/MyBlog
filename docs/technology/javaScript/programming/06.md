---
title: 06. 对象、类与面向对象编程
---

## 理解对象

### 属性类型

属性分为两种：**数据**属性和**访问器**属性。

#### 数据属性

数据属性有4个特性描述它们的行为：

- `[[Configurable]]`：表示属性是否可以通过`delete`删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认是`true`
- `[[Enumerable]]`：表示属性是否可以通过`for-in`循环返回。默认是`true`
- `[[Writable]]`：表示属性的值是否可以被修改。默认是`true`。
- `[[Value]]`：包含属性实际的值。默认值为`undefined`。

要**修改属性的默认特性**，就必须使用`Object.defineProperty()`方法。这个方法接收3个参数：要给其添加属性的**对象**、属性的**名称**和一个**描述符对象**。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable和value，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。

```js
let person = {};
Object.defineProperty(person, "name", {
  writable: false,
  value: "Nicholas"
};
console.log(person.name); // "Nicholas"
person.name = "Greg";
console.log(person.name); // "Nicholas"
```

一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用`Object.defineProperty()`并修改任何非`writable`属性会导致错误。

#### 访问器属性

访问器属性有4个特性描述它们的行为。

- `[[Configurable]]`：表示属性是否可以通过`delete`删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认是`true`
- `[[Enumerable]]`：表示属性是否可以通过`for-in`循环返回。默认是`true`
- `[[Get]]`：获取函数，在读取属性时调用。默认值为`undefined`。
- `[[Set]]`：设置函数，在写入属性时调用。默认值为`undefined`。

访问器属性是不能直接定义的，必须使用`Object.defineProperty()`。

### 定义多个属性

在一个对象上同时定义多个属性

`Object.defineProperties(obj, description);`

### 读取属性的特性

取得指定属性的属性描述符

`Object.getOwnPropertyDescriptor(obj, descriptor);`

`ECMAScript 2017`新增了`Object.getOwnPropertyDescriptors()`静态方法。这个方法实际上会在**每个自有属性**上调用`Object.getOwnPropertyDescriptor()`并在一个新对象中返回它们。

### 合并对象

`Object.assign(target, source)`

- target - 目标对象
- source - 一个或多个源对象。

`Object.assign`修改目标对象，也会返回修改后的目标对象。

浅复制；如果多个源对象都有**相同的属性**，则**使用最后一个**复制的值。不能在两个对象间转移获取函数和设置函数。

### 对象标识及相等判定

有些特殊情况即使是===操作符也无能为力，考虑到了上述边界情形。`ECMAScript 6`规范新增了`Object.is()`。

```js
// 这些情况在不同JavaScript引擎中表现不同，但仍被认为相等
console.log(+0 === -0); // true
console.log(+0 === 0); // true
console.log(-0 === 0); // true
// 要确定NaN的相等性，必须使用极为讨厌的isNaN()
console.log(NaN === NaN); // false
console.log(isNaN(NaN)); // true
```

```js
// 正确的0、-0、+0相等/不等判定
console.log(Object.is(+0, -0)); // false
console.log(Object.is(+0, 0)); // true
console.log(Object.is(-0, 0)); // false
// 正确的NaN相等判定
console.log(Object.is(NaN, NaN)); // true
```

### 增强的对象语法

- 属性简写（属性名和变量名一样时，可简写）
- 可计算属性（`obj[expression]`）
- 简写方法名（可省略function关键字）

### 对象结构

```js
let person = {name: "wen", age: 28 }
let { name, age } = person
```

## js 创建对象的方式

### 1. 字面量

### 2. new Object()

字面量和`new Object()`方式在使用同一个接口创建多个对象时，会产生**大量的重复代码**。

### 3. 工厂模式
  
抽象创建特定对象。传入参数，使用new Object(),添加对象的属性和方法，然后return对象。

解决：创建多个类似对象的问题。

问题：对象标识问题，**不确定新对象是什么类型**。

### 4. 构造函数模式

创建特定类型对象。自定义构造函数，以函数形式为自己对象类型定义属性和方法。构造函数名字**首字母大写**。

`new` 操作符调用构造函数创建一个实例对象。使用`instanceof`来检测构造函数的原型对象**是否存在**传入的**对象原型链上**。

问题：定义的方法会在**每个实例上都创建一遍**

问题的解决：可以把函数定义转移到构造函数外部

解决后的新问题：自定义类型引用的**代码不能很好地聚集**在一起。(对象上需要多个方法，就要在全局作用域中定义多个方法)

### 5. 原型模式

在它上面定义的属性和方法可以被对象实例共享。

原来在构造函数中直接赋值给对象实例的值，可以直接赋值给它们的原型。

问题：**它的共享性**。实例共享属性和方法，覆盖原型对象上的同名属性和方法。

### 6. 混合模式

构造函数 + 原型模式

混合模式共享着相同的方法的引用，有保证每个实例有自己的私有属性。最大限度的节省了内存。

## js 继承的方式

### 1. 原型链继承

`SubType.prototype = new SuperType();`

缺点：父类中包含的**引用值会在所有实例间共享**。即修改一个实例原型上引用值的属性会影响另外一个。

### 2. 构造函数继承

`function child() { parent.call(this) }`

缺点：**不能继承父类构造函数中的方法**。

### 3. 组合继承

原型继承 + 构造函数继承

缺点：父类构造函数被调用了两次（创建子类原型`sub.prototype = new sup()`和子类构造函数`sup.call(this)`）

### 4. 原型式继承

`Object.create(sup);`

```js
let sup = {
  name: "wen",
  age: 28,
  friends: ['zs','ls']
};
let sub = Object.create(sup);
```

缺点：属性中的引用值始终会在相关对象之间共享。和原型链继承缺点一样。

### 5. 寄生式继承

寄生式继承背后的思路类似于构造函数和工厂模式：

创建一个实现继承的函数，在函数(`createObj`)内使用`let clone = Object.create(argObj);`，增强对象（`clone.sayHi()`），然后返回这个对象。

使用：`let obj = {...}; let sub = createObj(obj);`

缺点：通过寄生式继承给对象添加函数会导致**函数难以重用**，与构造函数模式类似。

### 6. 寄生组合继承

思路：使用寄生式继承父类原型，然后将返回的新对象赋值给子类原型。

```js
function inheritPrototype(child,parent){
  // 创建对象，创建父类原型的一个副本 
  let prototype= Object.create(parent.prototype); 
  // 增强对象，弥补因重写原型而失去的默认的 constructor 属性 
  prototype.constructor = child;
  // 指定对象，将新创建的对象赋值给子类的原型 
  child.prototype = prototype; 
}
```

寄生式组合继承可以算是引用类型继承的最佳模式。

## 类

基于原型机制的语法糖。可以继承**内置**类型，也可以继承**自定义**类型。有效跨越了**对象实例、对象原型和对象类**的鸿沟。



## 小结
