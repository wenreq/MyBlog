---
title: 04. 集合引用类型
---

# Object、Array、Map WeakMap、Set WeakSet

## 对象

- 创建：1.`new Object();` 2. 对象字面量 `let obj = {};`
- 数值属性会**自动转换**为字符串；使用对象字面量，不会实际调用 `Object` 构造函数。
- 取值：属性可以使用**点**和**中括号**语法存取，中括号优势是可以通过**变量**访问属性。

## 数组

每个槽位可以存储**任意类型**的数据。数组也可以是**动态大小的**。

### 1) 创建

- **Array 构造函数** `new Array(1, 2, 3); // [1, 2, 3]`
- **数组字面量** `let arr = [1, 2, 3]; // [1, 2, 3]`
- **Array.from(arg1, arg2, arg3)** `Array.from([1, 2, 3]); // [1, 2, 3]`
  arg1: 一个类数组对象。
  arg2: 可选，映射函数参数，增强新数组的值。
  arg3: 可选，用于指定映射函数中的 this。
- **Array.of()** `Array.of(1, 2, 3); // [1, 2, 3]` 可以把一组参数转换为数组。

`Array.of()` 替代在 `ES6` 之前常用的 `Array.prototype.slice.call(arguments)` 一种异常笨拙的将 `arguments` 对象转化为数组的写法。

```js
Array.prototype.slice.call('wen'); // ['w', 'e', 'n']
Array.of('w', 'e', 'n'); // ['w', 'e', 'n']
```

### 2) 数组空位

ECMAScript 会将逗号之间相应索引位置的值当成空位。

创建空位数组：

```js
[,,,,,,]
Array.from([,,,,,,])
Array.of(...[,,,,,,])
```

### 3) 数组索引

要取得或设置数组的值，需要使用**中括号**并提供相应值的数字索引。`Arr[index]`。

数组中的 `length` 可以从数组末尾删除或添加元素。

### 4) 检测数组

```js
value instanceof Array; // 假设只有一个全局执行上下文

Array.isArray(value); // 确定一个值是否为数组

Object.prototype.toString.call(value).slice(8, -1); // 准确检测数据类型的方法
```

### 5) 迭代方法

- **keys()** 返回数组 **索引** 的迭代器 `[1,2,3].keys().next()`
- **values()** 返回数组 **元素** 的迭代器 `[1,2,3].values().next()`
- **entries()** 返回 **索引/值** 的迭代器 `[1,2,3].entries().next()`

### 6) 复制和填充方法

***不会改变数组的大小***

- 复制数组方法 `copyWithin()`
- 填充数组方法 `fill()`

```js
[0, 0, 0, 0, 0].fill(7, 1, 3); // 用 7 填充，索引大于等于 1 且小于 3 的元素
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9].copyWithin(4, 0, 3); // 从数组中复制，索引 0 开始到索引 3 结束的内容，插入替换掉索引 4 开始的位置
```

### 7) 转换方法

- `valueOf()` 返回数组本身
- `toString()` 返回等效字符串拼接而成的一个逗号分隔的字符串
- `toLocaleString()` 返回一个逗号分隔的数组值的字符串

继承的方法 toLocaleString()以及 toString()都返回数组值的逗号分隔字符串。如果想使用不用逗号分隔符可以，使用 join()方法。

`[1, 2, 3].join('-'); // '1-2-3'`

### 8) 栈方法

- `push()` 添加到数组末尾
- `pop()` 删除数组最后一项

### 9) 队列方法

- `unshift()` 添加到数组头部
- `shift()` 删除数组第一项

### 10) 排序方法

- `reverse()` 反向排列数组
- `sort()` 按升序排列数组元素，小的在前，大的在后

```js
'1, 2, 3'.split(',').reverse().join(','); // '3, 2, 1'
[3, 2, 1].sort(); // [1, 2, 3]
```

### 11) 操作方法

- `concat()` 数组的拼接
- `slice(startIndex, endIndex)` 创建一个新数组；返回元素的开始索引和结束索引
- `splice(index, num, element)` 在数组中插入元素；删除、插入、替换

### 12) 搜索和位置方法

#### 严格相等

- `indexOf(element)` 返回在数组中可以找到一个给定元素的**第一个索引**，如果不存在，则返回-1。
- `lastIndexOf()` 返回指定元素在数组中的**最后一个的索引**，如果不存在则返回 -1。
- `includes()` 用来判断一个数组**是否包含一个指定的值**，根据情况，如果包含则返回 `true`，否则返回 `false`。

#### 断言相等

- `find(element)` 返回第一个匹配的元素
- `findIndex()` 返回一个匹配元素的索引

### 13) 迭代方法

对数组每一项都运行传入的函数

- `every()` 每一项函数都返回 `true`，则这个方法返回 `true`。
- `some()` 如果有一项函数返回 `true`，则返回 `true`。
- `filter()` 函数返回 `true` 的项会组成数组之后的返回。
- `forEach()` 没有返回值

### 14) 归并方法

- `reduce()` 接收 2 个参数，对每一项都会运行的归并函数；归并起点的初始值。传递 4 个参数：**上一个归并值**、**当前项**、**当前索引**和**数组本身**。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。
- `reduceRight()` 接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。

```js
const array1 = [[0, 1], [2, 3], [4, 5]].reduceRight(
  (accumulator, currentValue) => accumulator.concat(currentValue)
);
console.log(array1);
// expected output: Array [4, 5, 2, 3, 0, 1]
```

## 定型数组

- `ArrayBuffer` 是所有定型数组及视图引用的基本单位。
- `ArrayBuffer()` 是一个普通的 `JavaScript` 构造函数，用于在内存中分配特定数量的字节空间。一经创建就不能调整大小。

## Map

`ECMAScript6` 新增特性，`Map` 是一种新的集合类型，为这门语言带来了**真正的键/值存储机制**。

### 基本API

创建

```js
const m = new Map([['name', 'wen'],['age', 28]]);
console.log(m);
// Map(2) {'name' => 'wen', 'age' => 28}
```

- `set()` 再添加键/值对（可多个操作连缀起来）
- `get()` 和 `has()` 进行查询
- `size` 属性获取映射中的键/值对的数量
- `delete()` 和 `clear()` 删除值

## WeakMap

## Set

`Set` 为这门语言带来**集合数据**结构。

创建：

```js
const m = new Set(['1','2','3']);
console.log(m); // Set(3) {'1', '2', '3'}

console.log([...new Set(['1','2','3','2'])]); // ['1', '2', '3']
```

- `add()` 增加值（返回集合的实例，所以可以将多个操作连缀起来，包括初始化）
- `has()` 查询
- `size` 属性获取元素的数量
- `delete()` 和 `clear()` 删除元素。delete()返回一个布尔值， 表示集合中是否存在要删除的值。

## WeakSet

## 迭代与扩展操作

有四种原生集合类型定义了默认迭代器：

- Array
- 所有的定型数组
- Map
- Set
  
这意味着上述所有类型都支持顺序迭代，都可以传入 `for-of` 循环。

## 小结

`JavaScript` 中的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。

- 引用类型与传统面向对象编程语言中的类相似，但实现不同。
- `Object` 类型是一个基础类型，所有引用类型都从它继承了基本的行为。
- `Array` 类型表示一组有序的值，并提供了操作和转换值的能力。
- `Date` 类型提供了关于日期和时间的信息，包括当前日期和时间以及计算。
- `RegExp` 类型是 `ECMAScript` 支持的正则表达式的接口，提供了大多数基本正则表达式以及一些高级正则表达式的能力。

JavaScript比较独特的一点是，函数其实是 `Function` 类型的实例，这意味着函数也是对象。由于函数是对象，因此也就具有能够增强自身行为的方法。

因为原始值包装类型的存在，所以 `JavaScript` 中的原始值可以拥有类似对象的行为。有3种原始值包装类型：`Boolean`、`Number`和`String`。它们都具有如下特点。

- 每种包装类型都映射到**同名的原始类型**。
- 在以读模式访问原始值时，后台会实例化一个**原始值包装对象**，通过这个对象可以操作数据。
- 涉及原始值的语句只要一执行完毕，包装对象就会**立即销毁**。

`JavaScript`还有两个在一开始执行代码时就存在的内置对象：`Global`和`Math`。其中，`Global`对象在大多数`ECMAScript`实现中无法直接访问。不过浏览器将`Global`实现为`window`对象。所有全局变量和函数都是`Global`对象的属性。`Math`对象包含辅助完成复杂数学计算的属性和方法。

`ECMAScript 6`新增了一批引用类型：`Map`、`WeakMap`、`Set`和`WeakSet`。这些类型为**组织应用程序数据**和**简化内存管理**提供了新能力。
