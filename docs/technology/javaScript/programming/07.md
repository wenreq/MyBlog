---
title: 07. 代理与反射
---

## 代理基础

`ECMAScript6` 新增的代理和反射提供了**拦截**并向基本操作嵌入**额外行为**的能力。

给目标对象关联一个代理对象，这个代理对象可以作为抽象的目标对象来使用，在操作影响目标对象前，可以在代理对象中对这些操作加以控制。

### 创建代理

使用 `Proxy` 构造函数创建的。接受两个参数：目标对象和处理程序对象。`let proxy = new Proxy(targetObject, handler);`

在代理对象上执行的任何操作实际上都会应用到目标对象上。

用严格相等可以区分代理和目标。`console.log(target === proxy); // false`

### 定义捕获器

使用代理的主要目的是可以定义捕获器。捕获器就是处理程序对象中定义的**基本操作的拦截器**。

每个捕获器对应一种操作，可以直接或间接在代理对象上调用。

每次在代理对象上调用这些基本操作时，代理可以在这些操作**传播到目标对象之前**先调用捕获器函数，从而**拦截并修改**相应的行为。

捕获器（trap）是从操作系统中借用的概念。操作系统中，它是程序流中的一个**同步中断**，可以暂停程序流，转而执行一段子流程，之后再返回原始程序流。

`get()`、`set()` 捕获器

```js
const target = { foo: 'bar' };
const handler = {
  // 捕获器在处理程序对象中以方法名为键
  get() {
    return 'handler override';  
  }
};
const proxy = new Proxy(target, handler);
```

### 捕获器参数和反射API

`get(trapTarget, property, receiver) {}` `get()`捕获器会接收到目标对象、要查询的属性和代理对象三个参数。

有了这些参数，就可以**重建**被捕获方法的原始行为：

```js
get(trapTarget, property, receiver) { 
  return trapTarget[property]; 
}
```

实际上，开发者并**不需要手动重建**原始行为，而是可以通过调用**全局Reflect对象**上（封装了原始行为）的同名方法来轻松重建。

```js
const handler = { 
  get: Reflect.get
}; 
const proxy = new Proxy(target, handler);
```

如果真想创建一个可以**捕获所有方法**，然后将每个方法转发给对应反射API的空代理。`const proxy = new Proxy(target, Reflect);`

反射API为开发者准备好了样板代码，在此基础上开发者可以**用最少的代码修改捕获的方法**。(在某个属性被访问时，会对返回的值进行一番修饰)

```js
get(trapTarget, property, receiver) {
  let decoration = '';
  if (property === 'foo') {
    decoration = '!!!';
  }return Reflect.get(...arguments) + decoration;
}
```

### 捕获器不变式

捕获处理程序的行为必须遵循**捕获器不变式**，通常都会防止捕获器定义出现**过于反常**的行为。

比如，如果目标对象有一个*不可配置且不可写的数据*属性，那么在捕获器返回一个与该属性不同的值时，会抛出`TypeError`。

### 可撤销代理

有时候可能需要**中断**代理对象与目标对象之间的联系。

`revocable()`支持撤销代理对象与目标对象的关联。撤销代理的操作是**不可逆的**。

撤销函数（`revoke()`）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 `TypeError`。

撤销函数和代理对象是在**实例化时**同时生成的：

```js
const { proxy, revoke } = Proxy.revocable(target, handler); 
revoke();
```

### 实用反射API



### 代理另一个代理



### 代理的问题与不足

## 代码捕获器与反射方法



## 代理模式



## 小结
