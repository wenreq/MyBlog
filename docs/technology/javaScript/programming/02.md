---
lang: zh-CN
title: 02. 变量、作用域、内存
description: 变量、作用域、内存
---

# 原始值与引用值、执行上下文、垃圾回收

## 原始值与引用值

- 原始值：原始数据类型。
- 引用值：有多个原始类型构成的对象。

### - 动态属性

只有引用值可以动态添加后面可以使用的属性；原始类型使用 `new` 关键字创建一个 `Object` 类型的实例。

### - 复制值

原始值复制时，两个变量**独立**使用，互补干扰；引用值复制的值是一个指针，它指向储存在**堆内存**中的对象，两个变量指向**同一个**对象。

### - 传递参数

函数的参数就是**局部变量**

### - 确定类型

原始类型使用 **`typeof`**，引用类型使用 **`instanceof`**

两者都可以用 **`Object.prototype.toString.call(obj).slice(8, -1)`**

## 执行上下文

  每个上下文都有一个关联的**变量对象**，全局上下文是 `Window` 对象。

  上下文在其**所有代码都执行完毕后会被销毁**，包括定义的变量、函数。

  上下文代码执行时会创建**变量对象的一个作用域链**。

  局部作用域中定义的变量可用于在局部上下文中替换变量；内部上下文可以通过作用域链访问外部上下文中的一切，但外部无法访问内部的任何东西。

  先从**自己的变量对象**开始搜索变量和函数，搜索不到就会去搜索上一级变量对象。

### 1.作用域链增强

`try/catch` 语句的 `catch` 块和 `with` 语句。都会在作用域前端添加一个变量。

对 `with` 来说向作用域链前添加**指定对象**，`catch` 会创建一个**新的变量对象**。

```js
with(location) {
  // with 语句将 location 对象作为上下文
  let url = href + qs;
}
```

### 2.变量声明

#### - var 的函数作用域声明

会被自动添加最近的上下文。

省略 `var` 会被添加到全局上下文，函数退出，后面仍然可以访问；`var` 声明会被拿到函数或全局作用域的顶部。

#### - let 的块级作用域声明

块级作用域由最近的一对花括号 `{}` 界定。

同一作用域内不能声明两次。

适用在循环中声明迭代变量。

不能在声明前使用 `let` 变量，会形成**暂时性死区**。

#### - const 的常量声明

声明的变量同时初始化为某个值。

不能重新赋予新值。但对象的键则不受限制。想让对象不能修改，可以使用 `Object.freeze()`。

#### - 标识符查找

当在特定上下文中读取或写入而引用一个标识符时，在局部上下文中找到该标识符，则搜索停止，变量确定，，没有找到则继续沿作用域链搜索，一直持续到搜索全局上下文的变量对象，如果还没有找到标识符，则说明其未声明。

标识符查找并非没有代价，**访问局部变量比访问全局变量要快，因为不用切换作用域**。

## 垃圾回收

**通过自动管理内存实现内存分配和闲置资源回收**。其思路：确定哪个变量不会再使用，然后释放它占用的内存。这过程是周期性的，每隔一定时间就会自动运行。

### 标记清除

标记内存中存储的所有变量，去掉被上下文引用的变量，剩下的就是要删除的了。

### 引用计数

对每个值都记录它被引用的次数。

声明变量并赋一个引用值，这个值的引用数为 1。如果保存对该值的变量被其他值给覆盖了，那么引用数减 1。

垃圾回收程序下一次运行的时候就会释放引用数为 0 的值的内存。

引用计数存在**循环引用的问题**，引用数永远不为 0，如果函数被多次调用，会导致大量内存不会被释放。

### 性能

> 在一次完整的垃圾回收后，V8 的堆增长策略会根据活跃对象外加一些余量来确定何时再次垃圾回收。

IE 曾根据分配策略，比如分配了 256 个变量或 64kb 字符串，满足条件，垃圾回收程序就会执行，可能整个生命周期始终需要那么多变量，就会导致频繁地运行回收程序。

IE7 后，JS引擎的垃圾回收程序被调优为**动态分配**变量、字面量或数组等触发垃圾回收的阈值，如果有一次垃圾回收的内存达到已分配的 85%，则阈值重置为默认值。

### 内存管理

将内存占用量保持在一个较小的值可以让页面性能更好。数据不再必要，把它设置为 `null`，从而释放引用，这可以叫**解除引用**。适合**全局变量和全局对象**的属性。

**局部变量在超出作用域后会被自动解除引用**。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。

#### 通过 `const`、`let` 声明提升性能

这两个关键字会更早让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，有可能发生。

#### 隐藏类和删除操作

运行期间，V8 会将**对象与隐藏类**关联起来，以跟踪他们的属性。能够共享相同隐藏类的对象性能会更好。避免“先创建再补充”式的动态属性赋值，要在构造函数中一次性声明所有属性。

动态删除属性和动态添加属性导致的后果一样，不会共享一个隐藏类，最佳实践是把不想要的属性设为为 `null`。

#### 内存泄漏

意味声明全局变量会导致内存泄漏问题。解决：在变量声明前加上 `var`、`let`、`const`。

定时器和闭包，引用外部变量都会造成内存泄漏。

#### 静态分配和对象池

浏览器决定何时运行垃圾回收程序的一个标准就是**对象更替速度**。

不要动态创建矢量对象，使用对象池不会发生有对象更替。

## 小结

`JavaScript` 变量可以保存两种类型的值：原始值和引用值。原始值可能是以下 6 种原始类型 之一：`Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`。原始值和引用值有以下特点。

- 原始值大小固定，因此保存在栈内存上。
- 从一个变量到另外一个变量赋值原始值会创建该值的第二个副本。
- 引用值是对象，存储在堆内存上。
- 包含引用值的变量实际上只包含相应**对象的一个指针**，而不是对象本身。
- `typeof` 操作符可以确定值的原始类型，而 `instanceof` 操作符用于确保值的引用类型。

任何变量（不管包含的是原始值还是引用值）都存在于**某个执行上下文中**（也称为作用域）。 这个上下文（作用域）**决定了变量的声明周期**，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。

- 执行上下文分全局上下文、函数上下文、块级上下文。
- 代码执行流进每一个上下文，都会**创建一个作用域链**，用于搜索变量和函数。
- 函数或块的局部上下文中不仅可以访问自己作用域**内**的变量，而且也可以访问任何**包含上下文**乃至**全局**上下文中的变量。
- 变量的执行上下文用于确定什么时候释放内存。

JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript 的垃圾回收程序可以总结如下。

- **离开作用域的值**会被自动标记为可回收，然后在垃圾回收期间被删除。
- 主流的垃圾回收算法是**标记清理**，即先给当前不使用的值加上标记，再回来回收他们的内存。
- 引用计数是另外一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使 用这种算法，但某些旧版本的 IE 仍然会受这种算法的影响，因为 JavaScript 会访问非原生 JavaScript 对象（如 DOM 元素）。
- 引用计数在代码中存在循环引用时会出现问题。
- 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全 局对象、全局的属性和循环引用都应该在不需要时解除引用。
