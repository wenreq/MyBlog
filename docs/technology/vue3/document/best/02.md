---
title: 7.2 性能
lang: zh-CN
---

## 7.2.1 概述

网络性能的两个主要方面：

- **页面加载性能**：应用展示出内容与首次访问时变为可交互的速度。
- **更新性能**：应用响应用户输入更新的速度。

## 7.2.2 分析选项

为了提高性能，我们首先需要知道如何衡量它。用于生产部署的负载性能分析：[WebPageTest](https://www.webpagetest.org/)

用于本地开发期间的性能分析：Chrome 开发者工具“性能”面板，[app.config.performance](https://staging-cn.vuejs.org/api/application.html#app-config-performance) 将会开启 Vue 特有的性能标记，标记在 Chrome 开发者工具的性能时间线上。

## 7.2.3 页面加载优化

页面加载优化有许多跟框架无关的方面 - 这份 [web.dev 指南](https://web.dev/fast/)提供了一个全面的总结。这里，我们将主要关注和 Vue 相关的技巧。

### 包体积与 Tree-shaking 优化

一个最有效的提升页面加载速度的方法就是压缩 JavaScript 打包产物的体积。当使用 Vue 时有下面一些办法来减小打包产物体积：

- 尽可能地采用构建步骤
  - 如果使用的是相对现代的打包工具，许多 Vue 的 API 都是可以被 [tree-shake](https://developer.mozilla.org/zh-CN/docs/Glossary/Tree_shaking) 的。举个例子，如果你根本没有使用到内置的 `<Transition>` 组件，它将不会被打包进入最终的产物里。Tree-shaking 也可以**移除**你源代码中其他未使用到的模块。
  - 当使用了构建步骤时，模板会被预编译，因此我们无须在浏览器中载入 Vue 编译器。这在同样最小化加上 gzip 优化下会相对缩小 14kb 并避免运行时的编译开销。
- 在引入新的依赖项时要小心**包体积膨胀**！在现实的应用中，包体积膨胀通常因为无意识地引入了过重的依赖导致的。
  - 如果使用了构建步骤，应当尽量选择提供 ES 模块格式的依赖，它们对 tree-shaking 更友好。举个例子，选择 `lodash-es` 比 `lodash` 更好。
  - 查看依赖的体积，并评估与其所提供的功能之间的性价比。如果依赖对 tree-shaking 友好，实际增加的体积大小将取决于你从它之中导入的 API。像 [bundle.js.org](https://bundle.js.org/) 这样的工具可以用来做快速的检查，但是根据实际的构建设置来评估总是最准确的。
- 如果你基本上是以渐进式集成的模式使用 Vue，并选择避免使用构建步骤，请考虑使用 [petite-vue](https://github.com/vuejs/petite-vue) (只有 **6kb**) 来代替。

### 代码拆分

代码查分是指构建工具将应用程序包拆分为多个较小的块，然后可以**按需或并行加载**。通过适当的代码拆分，页面加载时需要的功能可以立即下载，而额外的块在**需要时才加载**，从而提高性能。

像 Rollup(Vite 就是基于它之上开发的)或者 Webpack 这样的打包器可以通过**探测 ESM 动态导入的语法**来自动拆分代码块：

```js
// lazy.js 及其依赖会被拆分到一个单独的块中
// 并只在 `loadLazy()` 调用时才加载
function loadLazy() {
  return import("./lazy.js");
}
```

懒加载对于页面初次加载时的优化帮助极大，它帮助应用暂时略过了那些不是立即需要的功能。在 Vue 应用中，这常常与 Vue 的异步组件搭配使用，为组件树创建分离的代码块：

```js
import { defineAsyncComponent } from "vue";

// 会为 Foo.vue 及其依赖创建单独的一个块
// 它只会按需加载
//（即该异步组件在页面中被渲染时）
const Foo = defineAsyncComponent(() => import("./Foo.vue"));
```

如果在客户端侧通过 Vue Router 构建了路由，那么强烈建议使用异步组件作为路由组件。查看[懒加载路由](https://router.vuejs.org/guide/advanced/lazy-loading.html)了解更多细节。

### SSR / SSG

纯粹的客户端渲染存在内容到达时间缓慢的问题。这可以通过采用服务端渲染 (SSR) 或者静态站点生成 (SSG) 来进行优化。

## 7.2.4 更新优化

### props 稳定性

### v-once

### v-memo

## 7.2.5 总体优化

### 大型虚拟列表

### 减少大型不可变解构的响应开销

### 避免不必要的组件抽象
