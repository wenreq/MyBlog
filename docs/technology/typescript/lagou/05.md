---
title: 4. 什么是字面量类型、类型推断、类型拓宽和类型缩小？
lang: zh-CN
---

TypeScript 会根据上下文环境自动推断出变量的类型，无须我们再写明类型注解。

我们把 TypeScript 这种**基于赋值表达式推断类型**的能力称之为 “类型推断”。

## 4.1 类型推断

在 TypeScript 中，类型标注声明是在变量之后（即类型后置），使用类型标注后置的好处是编译器可以通过代码所在的上下文推导其对应的类型，无须再声明变量类型。

```ts
{
  let x1 = 42; // 推断出 x1 的类型是 number
  let x2: number = x1; // ok
}
```

在上述代码中，x1 的类型被推断为 number，将变量赋值给 number 类型的变量 x2 后，不会出现任何错误。

在 TypeScript 中，具有**初始化值的变量**、**有默认值的函数参数**、**函数返回的类型** 都可以根据上下文推断出来。比如我们能根据 return 语句推断函数返回的类型，如下代码所示：

```ts
{
  /** 根据参数的类型，推断出返回值的类型也是 number */
  function add1(a: number, b: number) {
    return a + b;
  }
  const x1 = add1(1, 1); // 推断出 x1 的类型也是 number

  /** 推断参数 b 的类型是数字或者 undefined，返回值的类型也是数字 */
  function add2(a: number, b = 1) {
    return a + b;
  }
  const x2 = add2(1);
  const x3 = add2(1, "1"); // // ts(2345) Argument of type '"1"' is not assignable to parameter of type 'number | undefined
}
```

在上述 add1 函数中，我们 return 了变量 a + b 的结果，因为 a 和 b 的类型为 number，所以函数返回类型被推断为 number。

当然，拥有默认值的函数参数的类型也能被推断出来。比如上述 add2 函数中，b 参数被推断为 number | undefined 类型，如果我们给 b 参数传入一个字符串类型的值，由于函数参数类型不一致，此时编译器就会抛出一个 ts(2345) 错误。

## 4.2 上下文推断

变量的类型可以通过被**赋值**的值进行推断。除此之外，在某些特定的情况下，我们也可以通过变量所在的**上下文环境**推断变量的类型。

```ts
{
  type Adder = (a: number, b: number) => number;
  const add: Adder = (a, b) => {
    return a + b;
  };
  const x1 = add(1, 1);
  const x2 = add(1, "1"); // ts(2345) Argument of type '"1"' is not assignable to parameter of type 'number
}
```

这里我们定义了一个实现加法功能的**函数类型 Adder**（定义的 Adder 类型使用了 type 类型别名，这点会在 07 讲专门介绍），声明了**add**变量的类型为 Adder 并赋值一个匿名箭头函数，箭头函数参数 a 和 b 的类型和返回类型都没有显式声明。

TypeScript 通过 add 的类型 Adder 反向（通过变量类型推断出值的相关类型）推断出箭头函数参数及返回值的类型，也就是说函数参数 a、b，以及返回类型在这个**变量的声明上下文中被确定了**。

正是得益于 TypeScript 这种类型推导机制和能力，使得我们**无须显式声明**，即可直接通过上下文环境推断出变量的类型，也就是说此时类型可缺省。

缺省类型注解的变量还可以通过**类型推断**出类型。

```ts
{
  let str = "this is string"; // str: string
  let num = 1; // num: number
  let bool = true; // bool: boolean
}
{
  const str = "this is string"; // str: 'this is string'
  const num = 1; // num: 1
  const bool = true; // bool: true
}
```

如上述代码中注释说明，通过 let 和 const 定义的赋予了相同值的变量，其推断出来的类型**不一样**。比如同样是 'this is string'（这里表示一个字符串值），通过 let 定义的变量类型是 string，而通过 const 定义的变量类型是 'this is string'（这里表示一个字符串字面量类型）。

## 4.3 字面量类型

### 4.3.1 字符串字面量类型

### 4.3.2 数字字面量类型及布尔字面量类型

## 4.4 Literal Widening

## 4.5 Type Widening

## 4.6 Type Narrowing

## 4.7 小结与预告
