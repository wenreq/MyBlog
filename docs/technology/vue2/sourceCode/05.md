---
title: 5. template 模板是怎样通过 Compile 编译的
lang: zh-CN
---

## 1. compile

`compile` 编译可以分成 `parse`、 `optimize` 与 `generate` 三个阶段，最终需要得到 render function。

![compile](./img/compile.png)

以下面的 template 示例，来看解析的过程。

```vue
<div :class="c" class="demo" v-if="isShow">
  <span v-for="item in sz">{{ item }}</span>
</div>
```

```js
var html = '<div :class="c" class="demo" v-if="isShow"><span v-for="item in sz">{{item}}</span></div>';
```

## 2. parse

首先是 `parse`，`parse` 会用正则等方式将 template 模板中的字符串进行解析，得到指令、class、style等数据，形成 **AST**（在计算机科学中，**抽象语法树**（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源码的抽象语法结构的树状表现形式，这里特指编程语言的代码。）。

这个过程比较复杂，会涉及到比较多的正则进行字符串解析，我们来看一下得到的 AST 的样子。

```js
{
  /* 标签属性的map，记录了标签上属性 */
  'attrsMap': {
    ':class': 'c',
    'class': 'demo',
    'v-if': 'isShow'
  },
  /* 解析得到的:class */
  'classBinding': 'c',
  /* 标签属性v-if */
  'if': 'isShow',
  /* v-if的条件 */
  'ifConditions': [
    {
      'exp': 'isShow'
    }
  ],
  /* 标签属性class */
  'staticClass': 'demo',
  /* 标签的tag */
  'tag': 'div',
  /* 子标签数组 */
  'children': [
    {
      'attrsMap': {
        'v-for': "item in sz"
      },
      /* for循环的参数 */
      'alias': "item",
      /* for循环的对象 */
      'for': 'sz',
      /* for循环是否已经被处理的标记位 */
      'forProcessed': true,
      'tag': 'span',
      'children': [
        {
          /* 表达式，_s 是一个转字符串的函数 */
          'expression': '_s(item)',
          'text': '{{item}}'
        }
      ]
    }
  ]
}
```

最终得到的 AST 通过一些**特定**的属性，能够比较清晰地描述出**标签的属性**以及**依赖关系**。

接下来我们用代码来讲解一下，如何使用正则来把 template 编译成我们需要的 AST 的。

### 2.1 正则

首先我们定义下一接下来我们会用的正则。

```js
// 名字
const ncname = '[a-zA-Z_][\\w\\-\\.]*'; //  AZ,az,_ 中任意一个
// 单属性标识符
const singleAttrIdentifier = /([^\s"'<>/=]+)/
// 单属性赋值
const singleAttrAssign = /(?:=)/
// 单属性值
const singleAttrValues = [
  /"([^"]*)"+/.source,
  /'([^']*)'+/.source,
  /([^\s"'=<>`]+)/.source
]
// 属性
const attribute = new RegExp(
  '^\\s*' + singleAttrIdentifier.source +
  '(?:\\s*(' + singleAttrAssign.source + ')' +
  '\\s*(?:' + singleAttrValues.join('|') + '))?'
)
// 名字捕获
const qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')'
// 开始标签打开
const startTagOpen = new RegExp('^<' + qnameCapture)
// 开始标签闭合
const startTagClose = /^\s*(\/?)>/
// 结束标签
const endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>')
// 默认标签正则
const defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g
// 循环别名正则表达式 in of
const forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/
```

### 2.2 advance

因为我们解析 template 采用**循环进行字符串匹配**的方式，所以没匹配解析完一段我们需要将**已经匹配掉的去掉**，头部的指针指向下来需要匹配的部分。

```js
function advance(n) {
  index += n;
  html = html.substring(n);
}
```

举个例子，当我们把第一个 div 的头部标签全部匹配完毕之后，我们需要将这部分除去，也就是又右移动 43 个字符。

![advance](./img/advance.png)

调用 `advance` 函数

```js
advance(43);
```

得到结果

![advance_after](./img/advance_after.png)

### 2.3 parseHTML

首先我们需要定义个 `parseHTML` 函数，在里面我们循环解析 template 字符串。

```js
function parseHTML () {
  // 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕
  while (html) {
    let textEnd = html.indexOf('<');
    // html 字符串的第一个字符就是左尖括号
    if(textEnd === 0) {
      // End tag:  结束标签
      if(html.match(endTag)) {
        // ... process end tag
        continue;
      }
      // Start tag: 开始标签
      if(html.match(startTagOpen)) {
        // ... process start tag
        continue;
      }
    } else {
      // ... process text
      continue;
    }
  }
}
```

`parseHTML` 会用 `while` 来循环解析 template，用正则在匹配到标签头、标签尾以及文本的时候分别进行不同的处理。直到整个 template 被解析完毕。

### 2.4 parseStartTag

我们来写一个 `parseStartTag` 函数，用来**解析起始标签**（`'<div :class="c" class="demo" v-if="isShow">'`部分的内容）。

```js
function parseStartTag () {
  // 首先用 startTagOpen 正则得到标签的头部，可以得到 tagName（标签名称），同时我们需要一个数组 attrs 用来存放标签内的属性。
  // 如果匹配成功，那么 start 将是一个包含两个元素的数组：第一个元素是标签的开始部分(包含< 和 标签名称)；第二个元素是捕获组捕获到的标签名称。
  // start = ['<div', 'div', index: 0, input: '<div :class="c" class="demo" v-if="isShow">', groups: undefined ]
  const start = html.match(startTagOpen);
  if(start) {
    const match = {
      // 它的值为 start[1] 即标签的名称。
      tagName: start[1], // div
      // 用来存储将来被匹配到的属性。
      attrs: [],
      // 初始值为 index，是当前字符流读入位置在整个 html 字符串中的相对位置。
      start: index // 0
    }
    advance(start[0].length); // advance(4) -> ':class="c" class="demo" v-if="isShow">'

    let end, attr
    // 接下来使用 startTagClose 与 attribute 两个正则分别用来解析标签结束以及标签内的属性。这段代码用 while 循环一直到匹配到 startTagClose 为止，解析内部所有的属性。
    // 没有匹配到开始标签的结束部分 且 有匹配到了属性；将每一个属性的对应的 name、value push 到 match 变量的 attrs 属性中去。
    // [':class="c"', ':class', '=', 'c', undefined, undefined, index: 0, input: ':class="c" class="demo" v-if="isShow">', groups: undefined]
    while(!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
      advance(attr[0].length) // advance(10)
      match.attrs.push({
        name: attr[1], // ':class'
        value: attr[3] // 'c'
      });
    }
    // 匹配到结束标签，结束。'>'.match(/^\s*(\/?)>/) -> ['>', '', index: 0, input: '>', groups: undefined]
    if(end) {
      match.unarySlash = end[1]; // unarySlash 一元斜线
      advance(end[0].length);
      match.end = index; // 添加了一个end属性 值为index
      return match; // 将match 对象作为 parseStartTag 函数的返回值返回
    }
  }
}
```

我们模拟假设有如下html（template）字符串：

```js
<div id="box" v-if="watings"></div>
```

则parseStartTag函数的返回值如下

```js
match = {
  tagName: 'div',
  attrs: [
    [
      'id="box"',
      'id',
      '=',
      'box',
      undefined,
      undefined
    ],
    [
      ' v-if="watings"',
      'v-if',
      '=',
      'watings',
      undefined,
      undefined
    ]
  ],
  start: index,
  unarySlash: undefined,
  end: index
}
```

### 2.5 stack

此外，我们需要维护一个 `**stack**` 栈来保存已经解析好的标签头，这样我们可以根据在解析尾部标签的时候得到所属的层级关系以及父标签。同时我们定义一个 `currentParent` 变量用来存放**当前标签的父标签节点的引用**， `root` 变量用来指向**根标签节点**。

```js
const stack = [];
let currentParent, root;
```

![stack](./img/stack.png)

知道这个以后，我们优化一下 `parseHTML` ，在 `startTagOpen` 的 `if `逻辑中加上新的处理。

```js
if(html.match(startTagOpen)) {
  // 将 startTagMatch 得到的结果首先封装成 element ，这个就是最终形成的 AST 的节点，标签节点的 type 为 1。
  const startTagMatch = parseStartTag();
  const element = {
    type: 1,
    tag: startTagMatch.tagName,
    lowerCasedTag: startTagMatch.tagName.toLowerCase(),
    attrsList: startTagMatch.attrs,
    attrsMap: makeAttrsMap(startTagMatch.attrs),
    parent: currentParent,
    children: [],
  }
  // 没有根节点，让 root 指向根节点的引用。
  if(!root) {
    root = element
  }
  // 将当前节点的 element 放入父节点 currentParent 的 children 数组中。
  if(currentParent) {
    currentParent.children.push(element);
  }
  // 最后将当前节点 element 压入 stack 栈中，并将 currentParent 指向当前节点，因为接下去下一个解析如果还是头标签或者是文本的话，会成为当前节点的子节点，如果是尾标签的话，那么将会从栈中取出当前节点，这种情况我们接下来要讲。
  stack.push(element);
  currentParent = element;
  continue;
}

// 其中的 makeAttrsMap 是将 attrs 转换成 map 格式的一个方法。
function makeAttrsMap(attrs) {
  const map = {}
  for (let i = 0; i < attrs.length; i++) {
    map[attts[i].name] = attrs[i].value;
  }
  return map;
}
```

### 2.6 parseEndTag

同样，我们在 `parseHTML` 中加入对尾标签的解析函数，为了匹配如 “`</div>`”。

```js
// '</div>'.match(endTag) -> [ '</div>', 'div', index: 0, input: '</div>', groups: undefined ]
const endTagMatch = html.match(endTag)
if (endTagMatch) {
  advance(endTagMatch[0].length); // advance(6)
  parseEndTag(endTagMatch[1]); // parseEndTag('div')
  continue;
}
```

用 `parseEndTag` 来解析尾标签，它会从 stack 栈中取出**最近**的跟自己**标签名一致**的那个元素，将 `currentParent` 指向那个元素，并将该元素都从 stack 中出栈。

```html
<div>
  <span></span>
  <span></span>
  <br />
  <span>
</div>
```

```js
function parseEndTag(tagName) {
  let pos;
  for (pos = stack.length - 1; pos >= 0; pos--) {
    if(stack[pos].lowerCasedTag === tagName.toLowerCase()) {
      break;
    }
  }
  if(pos >= 0) {
    stack.length = pos;
    currentParent = stack[pos]
  }
}
```

### 2.7 parseText

最后是解析文本，这个比较简单，只需要将文本取出，然后有两种情况，一种是**普通**的文本，直接构建一个节点 push 进当前 `currentParent` 的 children 中即可。还有一种情况是文本是如 "{{ item }}" 这样的 Vue.js 的**表达式**，这时候我们需要用 `parseText` 来将表达式转化成代码。

```js
text = html.substring(0, textEnd)
advance(textEnd)
let expression;
// 含表达式文本
if(expression = parseText(text)) {
  currentParent.children.push({
    type: 2,
    text,
    expression
  });
} else { // 纯文本
  currentParent.children.push({
    type: 3,
    text
  })
}
```

用到一个 `parseText` 函数。

```js
function parseText (text) {
  // /\{\{((?:.|\n)+?)\}\}/g.test('hello world') -> false
  // /\{\{((?:.|\n)+?)\}\}/g.test('{{item}}') -> true
  if(!defaultTagRE.test(text)) return; // 如果没有匹配到文本中有表达式，则直接返回。
  const tokens = [];
  let lastIndex = defaultTagRE.lastIndex = 0
  let match, index
  // /\{\{((?:.|\n)+?)\}\}/g.exec('{{item}}') ->  (2) ['{{item}}', 'item', index: 0, input: '{{item}}', groups: undefined]
  // /\{\{((?:.|\n)+?)\}\}/g.exec('标签{{item}}') -> (2) ['{{item}}', 'item', index: 2, input: '标签{{item}}', groups: undefined]
  while (match = defaultTagRE.exec(text)) {
    index = match.index
    if(index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)))
    }
    const exp = match[1].trim()
    tokens.push(`_s(${exp})`)
    lastIndex = index + match[0].length
  }
  if(lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+')
}
```

我们使用一个 `tokens` 数组来存放解析结果，通过 `defaultTagRE` 来循环匹配该文本，如果是普通文本直接 `push` 到 `tokens` 数组中去，如果是表达式（`{{item}}`），则转化成“`_s(${exp})`”的形式。

举个例子，如果我们有这样一个文本。

```js
<div>hello,{{name}}.</div>
```

最终得到 `tokens`。

```js
tokens = ['hello,', _s(name), '.'];
```

最终通过 `join` 返回表达式。

```js
'hello,' + _s(name) + '.'; 
```

### 2.8 processlf 与 processFor

最后介绍一下如何处理“`v-if`”以及“`v-for`”这样的 Vue.js 的表达式。

我们只需要在解析头标签的内容中加入这两个表达式的解析函数即可，在这时“`v-for`”之类指令已经在属性解析时存入了 `attrsMap` 中了。

```js
if (html.match(startTagOpen)) {
  const startTagMatch = parseStartTag();
  const element = {
    type: 1,
    tag: startTagMatch.tagName,
    attrsList: startTagMatch.attrs,
    attrsMap: makeAttrsMap(startTagMatch.attrs),
    parent: currentParent,
    children: []
  }

  processIf(element);
  processFor(element);

  if(!root){
    root = element
  }

  if(currentParent){
    currentParent.children.push(element);
  }

  stack.push(element);
  currentParent = element;
  continue;
}
```

首先我们需要定义一个 `getAndRemoveAttr` 函数，用来从 `el` 的 `attrsMap` 属性或是 `attrsList` 属性中取出 `name` 对应值。

```js
function getAndRemoveAttr (el, name) {
  let val
  if((val = el.attrsMap[name]) != null) {
    const list = el.attrsList
    for (let i = 0; i < list.length; i++) {
      if(list[i].name === name) {
        list.splice(i, 1)
        break
      }
    }
  }
  return val
}
```

比如说解析示例的 div 标签属性。

```js
getAndRemoveAttr(el, 'v-for');
```

可有得到“`item in sz`”。

有了这个函数这样我们就可以开始实现 `processFor` 与 `processIf` 了。

“v-for”会将指令解析成 `for` 属性以及 `alias` 属性，而“v-if”会将条件都存入 `ifConditions` 数组中。

```js
function processFor(el) {
  let exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) { // exp -> 'item in sz'
    // 'item in sz'.match(/(.*?)\s+(?:in|of)\s+(.*)/) -> ['item in sz', 'item', 'sz', index: 0, input: 'item in sz', groups: undefined]
    const inMatch = exp.match(forAliasRE);
    el.for = inMatch[2].trim() // 'sz'.trim()
    el.alias = inMatch[1].trim(); // 'item'.trim()
  }
}

function processIf (el) {
  const exp = getAndRemoveAttr(el, 'v-if');
  // exp -> isShow
  if(exp) {
    el.if = exp;
    if (!el.ifConditions) {
      el.ifConditions = [];
    }
    el.ifConditions.push({
      exp: exp,
      block: el
    })
  }
}
```

到这里，我们已经把 `parse` 的过程介绍完了，接下来看一下 `optimize`。

## 3. optimize

### 3.1 isStatic

### 3.2 markStatic

### 3.3 markStaticRoots

### 3.4 optimize

## 4. generate

### 4.1 genIf

### 4.2 genFor

### 4.3 genText

### 4.4 genElement

### 4.5 generate
